#This script QCs the benthic REA data pulled directly from the reports that are generated by the mission application.
#It is designed to help flag errors to be corrected directly in the mission app.
#Created by Courtney Couch 5/23/19
rm(list=ls())

#LOAD LIBRARY FUNCTIONS ... 
#BH: I'll need to figure out this access.  Help please!
source("C:/Users/Courtney.S.Couch/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_BSR.R")
source("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/lib/core_functions.R")


## LOAD benthic data
setwd("C:/Users/Courtney.S.Couch/Documents/Courtney's Files/R Files/ESD/HARAMP2019")

ad1<-read.csv("leg1_adults.csv") #read in adult data
ad2<-read.csv("leg2_adults.csv");ad2<-subset(ad2,select=-c(ISLANDCODE,REGION_NAME.1)) #read in adult data
ad3<-read.csv("leg3_adults.csv");ad3<-subset(ad3,select=-c(ISLANDCODE,REGION_NAME.1)) #read in adult data

ad<-rbind(ad1,ad2,ad3)

head(ad)
sort(colnames(ad))

#Add a colony id (temporary)
ad$COLONYID<-seq(1:length(ad$COLONYID))

taxa<-read.csv("T:/Benthic/Data/SpGen_Reference/list_of_coral_species_0319.csv");taxa<-taxa[c(2,17)]
#colnames(taxa)[colnames(taxa)=="SPECIES"]<-"Taxoncode" #Change column name
head(taxa)
taxa<-subset(taxa,HAWAII=="Yes")
ad$sp_check<-ifelse(ad$Taxoncode %in% c(taxa$SPECIES),"ok","check")
tmp<-merge(ad,taxa,by=c("Taxoncode"),all.x=T)
tmp[is.na(tmp$Taxoncode),]
write.csv(tmp,"test.csv")
# Prepping Adult Data -----------------------------------------------------

#BH: assume functions from core_functions
ad$SITE<-SiteNumLeadingZeros(ad$SITE) # Change site number such as MAR-22 to MAR-0022


### Use these functions to look at data
head(ad)
tail(ad)
sort(colnames(ad))

#Create vector of column names to include then exclude unwanted columns from dataframe
#NOTE- I REMOVED RECENTDEAD_3 FOR NOW BECAUSE IT'S NOT IN THE APP REPORT
DATA_COLS<-c("MISSIONID","REGION_NAME","ISLAND","SITE","LATITUDE",	"LONGITUDE","REEF_ZONE","DEPTH_BIN","OBS_YEAR",
             "DATE_","SITEVISITID","HABITAT_CODE","DIVER","TRANSECT","SEGMENT","SEGWIDTH","SEGLENGTH",
             "COLONYID","Taxoncode","MORPH_CODE","COLONYLENGTH","OLDDEAD","Fragment.yn",
             "RECENTDEAD","RECENT_GENERAL_CAUSE_CODE","RECENT_SPECIFIC_CAUSE_CODE",
             "RECENTDEAD_2",	"RECENT_GENERAL_CAUSE_CODE_2","RECENT_SPECIFIC_CAUSE_CODE_2",	
             "RECENT_GENERAL_CAUSE_CODE_3","RECENT_SPECIFIC_CAUSE_CODE_3","CONDITION_1",
             "CONDITION_2","CONDITION_3","EXTENT","EXTENT_2","EXTENT_3","SEVERITY","SEVERITY_2","SEVERITY_3",
             "GENUS_CODE","S_ORDER","TAXONNAME","SITE_MIN_DEPTH","SITE_MAX_DEPTH","QC")

#remove extraneous columns
head(ad[,DATA_COLS])
ad<-ad[,DATA_COLS]


##Change column names to make code easier to code
#BH: practice exercise; execute with dlpyr::rename() using pipe operator
colnames(ad)[colnames(ad)=="Taxoncode"]<-"SPCODE" #Change column name
colnames(ad)[colnames(ad)=="RECENTDEAD"]<-"RDEXTENT1" #Change column name
colnames(ad)[colnames(ad)=="RECENT_GENERAL_CAUSE_CODE"]<-"GENRD1" #Change column name
colnames(ad)[colnames(ad)=="RECENT_SPECIFIC_CAUSE_CODE"]<-"RD1" #Change column name
colnames(ad)[colnames(ad)=="RECENTDEAD_2"]<-"RDEXTENT2" #Change column name
colnames(ad)[colnames(ad)=="RECENT_GENERAL_CAUSE_CODE_2"]<-"GENRD2" #Change column name
colnames(ad)[colnames(ad)=="RECENT_SPECIFIC_CAUSE_CODE_2"]<-"RD2" #Change column name
colnames(ad)[colnames(ad)=="RECENT_GENERAL_CAUSE_CODE_3"]<-"GENRD3" #Change column name
colnames(ad)[colnames(ad)=="RECENT_SPECIFIC_CAUSE_CODE_3"]<-"RD3" #Change column name

head(ad)


#Change NAs in the Taxon and genus code to AAAA
#BH: practice exercise; execute within either replace() or replace_na
ad$GENUS_CODE<-as.character(ad$GENUS_CODE)
ad$SPCODE<-as.character(ad$SPCODE)

ad$GENUS_CODE[is.na(ad$GENUS_CODE)]<-"AAAA"#change nas to AAAA
ad$SPCODE[is.na(ad$SPCODE)]<-"AAAA"#change nas to AAAA


##Calcuating segment and transect area and add column for transect area
ad<-Transectarea(ad)
sapply(ad,levels)
sapply(ad,class)

head(ad)
nrow(ad)

#Create Table of site where repeat segments were conducted 
sv<-ddply(ad,.(ISLAND),
          summarize,
          Count=length(unique(SITE)))
sum(sv$Count) #185 (just shy of our 5 site/day allocation)
sv

rep.seg<-subset(ad,TRANSECT==2) #subset just transect 2, which is the repeat segments

#Change segment numbers from 1,3,5,7 to 0-15 so it makes more sense for downstream analyses and comparision with SfM data
rep.seg$SEG<-NULL
for (i in c(1:nrow(rep.seg))){ #opening brace
  if(rep.seg$SEGMENT[i] =="1"){ #c&p
    rep.seg$SEG[i] = "0" #c&p
  } #c&p
  if(rep.seg$SEGMENT[i] =="3"){ #c&p
    rep.seg$SEG[i]= "5" #c&p
  } #c&p
  if(rep.seg$SEGMENT[i] =="5"){ #c&p
    rep.seg$SEG[i]= "10" #c&p
  } #c&p
  if(rep.seg$SEGMENT[i] =="7"){ #c&p
    rep.seg$SEG[i]= "15" #c&p
  } #c&p
} #c&p

#look at coverage of rep segs across islands and habitats
#BH:  are we cross-referencing these outputs against anything? i.e. paper datasheets? 
rep.seg$SITE_SEG<-paste(rep.seg$SITE,rep.seg$SEG,sep="_")
seg<-ddply(rep.seg,.(ISLAND),
          summarize,
          Count=length(unique(SITE_SEG)))
seg

seg<-ddply(rep.seg,.(HABITAT_CODE),
           summarize,
           Count=length(unique(SITE_SEG)))
seg


# Prep Juvenile data ------------------------------------------------------

## CREATE JUVENILE CLEAN ANALYSIS READY DATA ----
j<-read.csv("leg1_juveniles.csv")#read in juvenile data
# BH: this should be j3<-read.csv("leg3_juveniles.csv"), correct?
#j3<-read.csv("leg3_juveniles.csv")#read in juvenile data

#j<-rbind(j2,j3)

#segjuv<-subset(seg,Method=="JUVENILE")

#Create colony id that doesn't overlap with adults
j$temp<-seq(1:length(j$COLONYID))
j$COLONYID<-j$temp+5029


j$SITE<-SiteNumLeadingZeros(j$SITE)

sort(colnames(j))
#Create vector of column names to include then ejclude unwanted columns from dataframe
DATA_COLS<-c("MISSIONID","REGION_NAME","ISLAND","SITE","LATITUDE",	"LONGITUDE","REEF_ZONE","DEPTH_BIN","OBS_YEAR",
             "DATE_","SITEVISITID","HABITAT_CODE","DIVER","TRANSECTNUM","SEGMENT","SEGWIDTH",
             "SEGLENGTH","COLONYID","Taxoncode","COLONYLENGTH","GENUS","S_ORDER","MIN_DEPTH","MAX_DEPTH")

head(j[,DATA_COLS])
j<-j[,DATA_COLS]



##Change column names to make code easier to code
colnames(j)[colnames(j)=="SPECIES"]<-"SPCODE" #Change column name
colnames(j)[colnames(j)=="TRANSECTNUM"]<-"TRANSECT" #Change column name
colnames(j)[colnames(j)=="MIN_DEPTH"]<-"SITE_MIN_DEPTH" #Change column name
colnames(j)[colnames(j)=="MAX_DEPTH"]<-"SITE_MAX_DEPTH" #Change column name

#Change NAs in Genus and SPCODE to AAAA 
#BH:hmmm...just curious here, but why does the juvenile segment data have a value of "-" for no data under GENUS_CODE, but not adult segments (adults default to: NA)?
j$GENUS_CODE[j$GENUS_CODE=="-"]<-NA 
j$SPCODE[j$SPCODE=="-"]<-NA 

j$GENUS_CODE<-as.character(j$GENUS_CODE)
j$SPCODE<-as.character(j$SPCODE)

#Change NA to AAAA to ensure you keep the 0s in
j$GENUS_CODE[is.na(j$GENUS_CODE)]<-"AAAA"#change nas to AAAA
j$SPCODE[is.na(j$SPCODE)]<-"AAAA"#change nas to AAAA


##Calcuating segment and transect area and add column for transect area
j<-Transectarea(j)
sapply(j,levels)
head(j)
nrow(j)


# QC Checks ---------------------------------------------------------------
#Set up output csv file that reports the status of the qc checks
output<-data.frame(
QC_check<-character(),
Status<-character(),stringsAsFactors = FALSE)

output<-data.frame(
  QC_check,
  Status,stringsAsFactors = FALSE)

ad<-subset(TRANSECT==1)
j<-subset(TRANSECT==1)


#1. Check that all data has been QC'd. If the following code returns records then there are segments that have not been QC'd
ad[ad$QC=="-",]
j[j$QC=="-",]
output[1,]<-c("Data have been QC'd","")


#2. Check number of sites is correct
ddply(ad,.(ISLAND),summarize,temp=length(unique(SITE)))
output[2,]<-c("Number of sites is correct","")


#3. Benthic and fish sites do not overlap
#BH: goal is to make sure site visit alphanumeric names are unique (i.e. "do not overlap") for fish vs benthic by island?
fish<-read.csv(fish_sitevisit.csv)
test<-merge(sv[,Site,Island],fish[,Site,Island],by=c("Site","Island"))
test #sites that appear in this list are overlapping and should be discussed with the fish team and corrected with Michael

output[3,]<-c("Benthic and fish sites do not overlap","")


#4. Make sure that all sites have all segments. If segments are missing double check datasheets and keep a record of segments that weren't surveyed
#Also check for duplicate segments (multiple divers entered segment- there should only be 1 segment record/site)
test<-ddply(ad,.(SITE,SEGMENT,DIVER),summarize,temp=length(SEGMENT))
test<-ddply(test,.(SITE,SEGMENT),summarize,count=length(SEGMENT))

# if there are multiple segment entries for a given this needs to be fixed
test[test$count>1,] 

#Create a list of sites that have <=2 segments to double check that all segments were entered
test<-ddply(ad,.(SITE),summarize,count=length(unique(SEGMENT)))
test[test$count<3,] 

output[4,]<-c("All sites have all segments & no duplicate segments","")

#5. Check that depths are not null and Add a new column to sitevisit table and flags any sites that don't match depth ranges for a given depth bin
summary(sv$Max.depth)
summary(sv$Min.depth)

sv$db_ok<-NULL
for (i in c(1:nrow(sv))){ #opening brace
  if(sv$Depth.bin[i] =="Deep"& sv$Min.depth[i]>=60){ #c&p
    sv$db_ok[i] = "ok" #c&p
  } #c&p
  if(sv$Depth.bin[i] =="Mid"& sv$Min.depth[i]>20&sv$Max.depth[i]<60){ #c&p
    sv$db_ok[i] = "ok" #c&p
  } #c&p
  if(sv$Depth.bin[i] =="Shallow"& sv$Max.depth[i]<=20){ #c&p
    sv$db_ok[i] = "ok" #c&p
  } #c&p
} #closing curly brace for entire forloop

sv$db_ok[is.na(sv$db_ok)]<-"error"
subset(sv,db_ok=="error") #identify the sites that have incorrect depth bins
#BH: export this subset as record for Michael?

output[5,]<-c("Depth Bins Match site Depths","Send list to Michael of sites to fix")

#6. Any sites that have transects other than 1
ad[ad$TRANSECT!="1",]
j[j$TRANSECT!="1",]

output[6,]<-c("Transect number = 1","ok")

#check for sites that don't have transect photos

#7.Check for incorrect species
ddply(ad,.(DIVER,GENUS_CODE,SPCODE),summarize,temp=length(SPCODE))

output[7,]<-c("Species codes are correct","")

#8.That the columns have the appropripate type of data (e.g. numeric vs. text) & no errant codes (e.g. ble instead of BLE)
sapply(ad,levels)

output[8,]<-c("No errant codes","ask MA to change - to 0 in frag column, change dama to damg")

#9. Identify colonies <5cm in the adult database but not fragments (Fragments indicated as 0% recent dead and DAMB)
ad[ad$Fragment.yn!="-1"&ad$COLONYLENGTH<5&ad$Taxoncode!="PBER",]

output[9,]<-c("No adult colonies less than 5cm that aren't fragments","")


#11. Identify juvenile colonies that are >= 5cm
j[j$COLONY_LENGTH>=5]

output[11,]<-c("Juvenile size range is correct","NA","")


#12.Identify colonies with 0% recent dead, but PRED or DZGEN as general cause code- This check should result in 0 records
ad[ad$RDEXTENT1=="0"& ad$GENRD1!="-",]
ad[ad$RDEXTENT1=="0"& ad$RD1!="-",]
ad[ad$RDEXTENT2=="0"& ad$GENRD2!="-",]
ad[ad$RDEXTENT2=="0"& ad$RD2!="-",]
ad[ad$RDEXTENT3=="0"& ad$GENRD3!="-",]
ad[ad$RDEXTENT3=="0"& ad$RD3!="-",]
ad[ad$EXTENT_1=="0"& ad$CONDITION_1!="-",]
ad[ad$EXTENT_2=="0"& ad$CONDITION_2!="-",]
ad[ad$EXTENT_3=="0"& ad$CONDITION_3!="-",]

output[12,]<-c("Recent Dead cause is present, but %RD = 0","")

#13.Identify colonies with 0% recent dead, but PRED or DZGEN as general cause code- This check should result in 0 records
ad[ad$GENRD1!="-"& ad$RDEXTENT1=="-",]
ad[ad$GENRD2!="-"& ad$RDEXTENT2=="-",]
ad[ad$GENRD3!="-"& ad$RDEXTENT3=="-",]

output[13,]<-c("% Recent dead included if a cause was recorded","")

#14. Identify colonies with NO % recent dead. Double check that these shouldn't be 0
ad[ad$RDEXTENT1=="-",]
ad[ad$RDEXTENT2=="-",]
ad[ad$RDEXTENT3=="-",]

output[14,]<-c("No missing %RD values","")

#15. Identify colonies with NO % EXTENT, but a condition. Double check that these shouldn't be 0
ad[ad$EXTENT=="-"& ad$CONDITION_1!="-",]
ad[ad$EXTENT_2=="-"& ad$CONDITION_2!="-",]
ad[ad$EXTENT_3=="-"& ad$CONDITION_3!="-",]

output[15,]<-c("All colonies with a condition have extent","")


#16. Identify colonies with nothing in condition column, but a value in extent
ad[ad$CONDITION_1=="-"& ad$EXTENT!="-",]
ad[ad$CONDITION_2=="-"& ad$EXTNET_2!="-",]
ad[ad$CONDITION_3=="-"& ad$EXTENT_3!="-",]

output[16,]<-c("Identify colonies with nothing in condition column, but a value in extent","")

#17. Identify colonies with nothing in condition column, but a value in severity. Double check that these shouldn't be 0
ad[ad$CONDITION_1=="-"& ad$SEVERITY!="-",]
ad[ad$CONDITION_2=="-"& ad$SEVERITY_2!="-",]
ad[ad$CONDITION_3=="-"& ad$SEVERITY_3!="-",]

output[17,]<-c("Identify colonies with nothing in condition column, but a value in severity","")

#18. Identify colonies with NO % SEVERITY, but a condition. Double check that these shouldn't be 0
ad[ad$SEVERITY=="-"& ad$CONDITION_1 %in% c("BLE","BLP"),]
ad[ad$SEVERITY2=="-"& ad$CONDITION_2%in% c("BLE","BLP"),]
ad[ad$SEVERITY3=="-"& ad$CONDITION_3%in% c("BLE","BLP"),]

#If these should be 1-5 then ask Michael to change them- it's faster than doing it manually
output[18,]<-c("BLE cause is present, but severity is null","")

#19. RD + OD is not greater than 100%
ad$totaldead<=ad$RDEXENT1+ad$RDEXTENT2+ad$RDEXTENT3+ad$OLDDEAD
ad[ad$totaldead>100]

output[19,]<-c("RD + OD <=100%","")

#20. Make sure that "No.colony.observed" is either 0 or -1, there were cases where there was -, which should have been 0. This is a glitch in the app. Michael fixed it?

output[20,]<-c("No colony observed column is 0 or -1","")


#21 Create maps of sites and confirm there are no errant sites
#for now import the site visit table into Arc.I'm working on a script to do this directly in R

output[21,]<-c("Site coordinates look good","ok")

#Export QC output table with appropriate file name
write.csv(output,"HARAMP2019_Leg1QC_output.csv")



####Generate a list of repeat segments
#BH: could we have repeat segments for juveniles too? I can't recall
a2<-read.csv("Leg2_adults.csv")
a3<-read.csv("Leg3_adults.csv")

all.<-rbind(a2,a3)

tr<-ddply(all.,.(ISLAND,SITE,DATE_,TRANSECT,SEGMENT,HABITAT_CODE,REEF_ZONE,DEPTH_BIN,SITE_MAX_DEPTH,SITE_MIN_DEPTH),
          summarize,
          temp=length(COLONYID))

rep.seg<-subset(tr,TRANSECT==2)

rep.seg$SEG<-NULL
  for (i in c(1:nrow(rep.seg))){ #opening brace
    if(rep.seg$SEGMENT[i] =="1"){ #c&p
      rep.seg$SEG[i] = "0" #c&p
    } #c&p
    if(rep.seg$SEGMENT[i] =="3"){ #c&p
      rep.seg$SEG[i]= "5" #c&p
    } #c&p
    if(rep.seg$SEGMENT[i] =="5"){ #c&p
      rep.seg$SEG[i]= "10" #c&p
    } #c&p
    if(rep.seg$SEGMENT[i] =="7"){ #c&p
      rep.seg$SEG[i]= "15" #c&p
    } #c&p
  } #c&p
write.csv(rep.seg,"HARAMP_Leg2_3_repeatsegments.csv")

