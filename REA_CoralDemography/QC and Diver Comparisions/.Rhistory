#This script QCs the PMNM 2017 REA data from the PMNM Acess database
setwd("T:/Benthic/Data/REA Coral Demography & Cover/Raw from Oracle")
#LOAD LIBRARY FUNCTIONS ...
library(tidyr)
library(reshape2)
library(dplyr)
source("C:/Users/Courtney.S.Couch/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_BSR.R")
source("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/lib/core_functions.R")
##read benthic data downloaded from Access
ad<-read.csv("PMNM 2017_V0_CORAL_OBS_E.csv") #read in adult data
j<-read.csv("PMNM 2017_V0_CORAL_OBS_F.csv") #read in adult data
#This script QCs the PMNM 2017 REA data from the PMNM Acess database
setwd("T:/Benthic/Data/REA Coral Demography & Cover/Raw from Oracle")
#LOAD LIBRARY FUNCTIONS ...
library(tidyr)
library(reshape2)
library(dplyr)
source("C:/Users/Courtney.S.Couch/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_BSR.R")
source("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/lib/core_functions.R")
##read benthic data downloaded from Access
ad<-read.csv("PMNM 2017_V0_CORAL_OBS_E.csv") #read in adult data
j<-read.csv("PMNM 2017_V0_CORAL_OBS_F.csv") #read in adult data
head(ad)
names(ad) <- toupper(names(ad))
head(ad)
df<-load("ALL_REA_ADULTCORAL_RAW_2013-2020.csv")
df<-load("ALL_REA_ADULTCORAL_RAW_2013-2020.Rdata")
head(df)
load("ALL_REA_ADULTCORAL_RAW_2013-2020.Rdata")
head(df)
colnames(df)
colnames(ad)
(15*6)/40
4965+1600
#This script QCs the PMNM 2017 REA data from the PMNM Acess database
setwd("T:/Benthic/Data/REA Coral Demography & Cover/Raw from Oracle")
#LOAD LIBRARY FUNCTIONS ...
library(tidyr)
library(reshape2)
library(dplyr)
source("C:/Users/Courtney.S.Couch/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_BSR.R")
source("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/lib/core_functions.R")
##read benthic data downloaded from Access
ad<-read.csv("PMNM 2017_V0_CORAL_OBS_E.csv") #read in adult data
j<-read.csv("PMNM 2017_V0_CORAL_OBS_F.csv") #read in adult data
load("ALL_REA_ADULTCORAL_RAW_2013-2020.Rdata")
#Change to uppercase
names(ad) <- toupper(names(ad))
names(j) <- toupper(names(j))
head(j)
levels(ad$SPECIES)
levels(as.factor(ad$SPECIES))
#This script QCs the PMNM 2017 REA data from the PMNM Acess database
setwd("T:/Benthic/Data/REA Coral Demography & Cover/Raw from Oracle")
#LOAD LIBRARY FUNCTIONS ...
library(tidyr)
library(reshape2)
library(dplyr)
source("C:/Users/Courtney.S.Couch/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_BSR.R")
source("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/lib/core_functions.R")
##read benthic data downloaded from Access
ad<-read.csv("PMNM 2017_V0_CORAL_OBS_E.csv") #read in adult data
j<-read.csv("PMNM 2017_V0_CORAL_OBS_F.csv") #read in adult data
load("ALL_REA_ADULTCORAL_RAW_2013-2020.Rdata")
#Change to uppercase
names(ad) <- toupper(names(ad))
names(j) <- toupper(names(j))
# Column Names Changes... -------------------------------------------------
colnames(ad)[colnames(ad)=="MAX_DEPTH"]<-"MAX_DEPTH_FT" #Change column name
colnames(ad)[colnames(ad)=="MIN_DEPTH"]<-"MIN_DEPTH_FT"
colnames(ad)[colnames(ad)=="MORPHOLOGY"]<-"MORPH_CODE" #Change column name
colnames(ad)[colnames(ad)=="TRAN"]<-"TRANSECTNUM" #Change column name
colnames(ad)[colnames(ad)=="SEG"]<-"SEGMENT" #Change column name
colnames(ad)[colnames(ad)=="TRLEN"]<-"SEGLENGTH" #Change column name
colnames(ad)[colnames(ad)=="TRWID"]<-"SEGWIDTH" #Change column name
colnames(ad)[colnames(ad)=="SPECIES"]<-"SPCODE" #Change column name
colnames(ad)[colnames(ad)=="GENUS"]<-"GENUS_CODE" #Change column name
colnames(ad)[colnames(ad)=="RECENTDEAD"]<-"RECENTDEAD_1" #Change column name
colnames(ad)[colnames(ad)=="RECENTGENERALCAUSECODE"]<-"RECENT_GENERAL_CAUSE_CODE_1" #Change column name
colnames(ad)[colnames(ad)=="RECENTSPECIFICCAUSECODE"]<-"RECENT_SPECIFIC_CAUSE_CODE_1" #Change column name
colnames(ad)[colnames(ad)=="DZCODE"]<-"COND" #Change column name
colnames(ad)[colnames(ad)=="FRAGMENT_YN"]<-"Fragment" #Change column name
colnames(ad)[colnames(ad)=="COND"]<-"CONDITION_1" #Change column name
colnames(j)[colnames(j)=="MAX_DEPTH"]<-"MAX_DEPTH_FT" #Change column name
colnames(j)[colnames(j)=="MIN_DEPTH"]<-"MIN_DEPTH_FT"
colnames(j)[colnames(j)=="MORPHOLOGY"]<-"MORPH_CODE" #Change column name
colnames(j)[colnames(j)=="TRAN"]<-"TRANSECTNUM" #Change column name
colnames(j)[colnames(j)=="SEG"]<-"SEGMENT" #Change column name
colnames(j)[colnames(j)=="TRLEN"]<-"SEGLENGTH" #Change column name
colnames(j)[colnames(j)=="TRWID"]<-"SEGWIDTH" #Change column name
colnames(j)[colnames(j)=="SPECIES"]<-"SPCODE" #Change column name
colnames(j)[colnames(j)=="GENUS"]<-"GENUS_CODE" #Change column name
#Add a colony id (temporary)
ad$COLONYID<-seq(1:length(ad$COLONYID))
# Prepping Adult Data -----------------------------------------------------
#Change NAs in the Taxon and genus code to AAAA & PEVE to PLUT
ad$GENUS_CODE<-as.character(ad$GENUS_CODE)
ad$SPCODE<-as.character(ad$SPCODE)
ad <- ad %>%
mutate(GENUS_CODE = replace(GENUS_CODE, GENUS_CODE == "", "AAAA"))  %>%
mutate(SPCODE = replace(SPCODE, SPCODE == "PEVE", "PLUT"))  %>%
mutate(SPCODE = replace(SPCODE, SPCODE == "", "AAAA"))
View(ad)
#4. Make sure that all sites have all segments. If segments are missing double check datasheets and keep a record of segments that weren't surveyed
test2<-ddply(ad,.(SITE,SEGMENT,DIVER),summarize,temp=length(SEGMENT))
head(test2)
eval <- acast(test2, SITE~SEGMENT, length)
test2<-ddply(ad,.(SITE,SEGMENT,DIVER),summarize,temp=length(SEGMENT))
test2$SS<-paste(test2$SITE,test2$SEGMENT,sep="_")
eval <- acast(test2, SITE~SEGMENT, length)
head(eval)
test2$SS<-paste(test2$SITE,test2$TRANSECTNUM,test2$SEGMENT,sep="_")
head(test2)
head(ad)
test2<-ddply(ad,.(SITE,TRANSECTNUM,SEGMENT,DIVER),summarize,temp=length(SEGMENT))
test2$SS<-paste(test2$SITE,test2$TRANSECTNUM,test2$SEGMENT,sep="_")
head(ad)
head(test2)
eval<-ddply(test2,.(SS),summarize,n=length(unique(SS)))
head(eval)
View(eval)
eval<-ddply(test2,.(SS),summarize,n=length(unique(SS)))
if(eval$n>1) {cat("duplicate segments")}   # should be 0
ifelse(eval$n>1,"duplicate segments","no issue")
head(test2)
eval2<-ddply(test2,.(STIE,TRANSECTNUM),summarize,n=length(unique(SEGMENT)))
eval2<-ddply(test2,.(SITE,TRANSECTNUM),summarize,n=length(unique(SEGMENT)))
evale
eval2
ad$MAX_DEPTH_M<-ad$MAX_DEPTH_FT*0.3048
ad$MIN_DEPTH_M<-ad$MIN_DEPTH_FT*0.3048
j$MAX_DEPTH_M<-j$MAX_DEPTH_FT*0.3048
j$MIN_DEPTH_M<-j$MIN_DEPTH_FT*0.3048
head(ad)
sv<-ad %>%
select (ISLAND, OBS_YEAR, SITE, LATITUDE, LONGITUDE, REEF_ZONE, DEPTH_BIN, DATE_, HABITAT_CODE, MAX_DEPTH_M , MIN_DEPTH_M ) %>%
distinct(SITE, .keep_all= TRUE)
View(sv)
ad$OBS_YEAR<-2017
j$OBS_YEAR<-2017
#5. Check that depths are not null and Add a new column to sitevisit table and flags any sites that don't match depth ranges for a given depth bin
sv<-ad %>%
select (ISLAND, OBS_YEAR, SITE, LATITUDE, LONGITUDE, REEF_ZONE, DEPTH_BIN, DATE_, HABITAT_CODE, MAX_DEPTH_M , MIN_DEPTH_M ) %>%
distinct(SITE, .keep_all= TRUE)
View(sv)
sv$db_ok<-NULL
for (i in c(1:nrow(sv))){ #opening brace
if(sv$DEPTH_BIN[i] =="Deep"& sv$MIN_DEPTH_M[i]>=60){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
if(sv$DEPTH_BIN[i] =="Mid"& sv$MIN_DEPTH_M[i]>20&sv$MAX_DEPTH_M[i]<60){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
if(sv$DEPTH_BIN[i] =="Shallow"& sv$MAX_DEPTH_M[i]<=20){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
} #closing curly brace for entire forloop
sv$db_ok[is.na(sv$db_ok)]<-"error"
subset(sv,db_ok=="error") #identify the sites that have incorrect depth bins
head(sv)
sv$db_ok<-NULL
head(sv)
sv$db_ok<-NULL
for (i in c(1:nrow(sv))){ #opening brace
if(sv$DEPTH_BIN[i] =="Deep"& sv$MIN_DEPTH_M[i]>=60){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
if(sv$DEPTH_BIN[i] =="Mid"& sv$MIN_DEPTH_M[i]>20&sv$MAX_DEPTH_M[i]<60){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
if(sv$DEPTH_BIN[i] =="Shallow"& sv$MAX_DEPTH_M[i]<=20){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
} #closing curly brace for entire for loop
sv$db_ok[is.na(sv$db_ok)]<-"error"
subset(sv,db_ok=="error") #identify the sites that have incorrect depth bins
sv$db_ok<-NULL
for (i in c(1:nrow(sv))){ #opening brace
if(sv$DEPTH_BIN[i] =="Deep"& sv$MIN_DEPTH_M[i]>=60){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
}
head(sv)
sv$db_ok<-NULL
for (i in c(1:nrow(sv))){ #opening brace
if(sv$DEPTH_BIN[i] =="Deep"& sv$MIN_DEPTH_M[i]>=60){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
if(sv$DEPTH_BIN[i] =="Mid"& sv$MIN_DEPTH_M[i]>20&sv$MAX_DEPTH_M[i]<60){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
if(sv$DEPTH_BIN[i] =="Shallow"& sv$MAX_DEPTH_M[i]<=20){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
} #closing curly brace for entire for loop
sv$db_ok<-NULL
for (i in c(1:nrow(sv))){ #opening brace
if(sv$DEPTH_BIN[i] =="Deep"& sv$MIN_DEPTH_M[i]>=60){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
if(sv$DEPTH_BIN[i] =="Mid"& sv$MIN_DEPTH_M[i]>20&sv$MAX_DEPTH_M[i]<60){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
}
levels(sv$DEPTH_BIN)
levels(as.factor(sv$DEPTH_BIN))
sv$db_ok<-NULL
for (i in c(1:nrow(sv))){ #opening brace
if(sv$DEPTH_BIN[i] =="Deep"& sv$MIN_DEPTH_M[i]>=18){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
if(sv$DEPTH_BIN[i] =="Mid"& sv$MIN_DEPTH_M[i]>6&sv$MAX_DEPTH_M[i]<18){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
if(sv$DEPTH_BIN[i] =="Shallow"& sv$MAX_DEPTH_M[i]<=6){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
} #closing curly brace for entire for loop
sv$db_ok[is.na(sv$db_ok)]<-"error"
subset(sv,db_ok=="error") #identify the sites that have incorrect depth bins
sv<-j %>%
select (ISLAND, OBS_YEAR, SITE, LATITUDE, LONGITUDE, REEF_ZONE, DEPTH_BIN, DATE_, HABITAT_CODE, MAX_DEPTH_M , MIN_DEPTH_M ) %>%
distinct(SITE, .keep_all= TRUE)
View(sv)
sv$db_ok<-NULL
for (i in c(1:nrow(sv))){ #opening brace
if(sv$DEPTH_BIN[i] =="Deep"& sv$MIN_DEPTH_M[i]>=18){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
if(sv$DEPTH_BIN[i] =="Mid"& sv$MIN_DEPTH_M[i]>6&sv$MAX_DEPTH_M[i]<18){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
if(sv$DEPTH_BIN[i] =="Shallow"& sv$MAX_DEPTH_M[i]<=6){ #c&p
sv$db_ok[i] = "ok" #c&p
} #c&p
} #closing curly brace for entire for loop
sv$db_ok[is.na(sv$db_ok)]<-"error"
subset(sv,db_ok=="error") #identify the sites that have incorrect depth bins
ddply(j,.(GENUS_CODE,SPCODE),summarize,temp=length(SPCODE))
#6.Check for incorrect species
ddply(ad,.(GENUS_CODE,SPCODE),summarize,temp=length(SPCODE))
j <- j %>%
mutate(GENUS_CODE = replace(GENUS_CODE, GENUS_CODE == "", "AAAA"))  %>%
mutate(SPCODE = replace(SPCODE, SPCODE == "PEVE", "PLUT"))  %>%
mutate(TAXONNAME = replace(TAXONNAME, TAXONNAME == "Porites evermanni", "Porites lutea"))  %>%
mutate(SPCODE = replace(SPCODE, SPCODE == "", "AAAA"))
View(j)
#7.That the columns have the appropripate type of data (e.g. numeric vs. text) & no errant codes (e.g. ble instead of BLE)
#BH: changed to unique...which shows the current values in the subset plus all possible levels
sapply(ad,unique)
subset(ad,SEGWIDTH>1)
sapply(j, unique)
