<<<<<<< HEAD
=======
CON_3 = mapvalues(CON_3, c(""), c(NA)))
sfm<-sfm %>% mutate(FRAGMENT = mapvalues(FRAGMENT, c(NA), c(0)),
REMNANT = mapvalues(REMNANT, c(NA), c(0)),
JUVENILE = mapvalues(JUVENILE, c(NA), c(0)),
EX_BOUND = mapvalues(EX_BOUND, c(NA), c(0)),
NO_COLONY = mapvalues(NO_COLONY, c(NA), c(0)),
RDCAUSE1 = mapvalues(RDCAUSE1, c(""), c(NA)),
RDCAUSE2 = mapvalues(RDCAUSE2, c(""), c(NA)),
RDCAUSE3 = mapvalues(RDCAUSE3, c("NA", ""), c(NA)),
CON_1 = mapvalues(CON_1, c(""), c(NA)),
CON_2 = mapvalues(CON_2, c(""), c(NA)),
CON_3 = mapvalues(CON_3, c("NA", ""), c(NA)))
sfm<-sfm %>% mutate(FRAGMENT = mapvalues(FRAGMENT, c(NA), c(0)),
REMNANT = mapvalues(REMNANT, c(NA), c(0)),
JUVENILE = mapvalues(JUVENILE, c(NA), c(0)),
EX_BOUND = mapvalues(EX_BOUND, c(NA), c(0)),
NO_COLONY = mapvalues(NO_COLONY, c(NA), c(0)),
RDCAUSE1 = mapvalues(RDCAUSE1, c(""), c(NA)),
RDCAUSE2 = mapvalues(RDCAUSE2, c(""), c(NA)),
RDCAUSE3 = mapvalues(RDCAUSE3, c("NA", ""), c(NA, NA)),
CON_1 = mapvalues(CON_1, c(""), c(NA)),
CON_2 = mapvalues(CON_2, c(""), c(NA)),
CON_3 = mapvalues(CON_3, c("NA", ""), c(NA, NA)))
which(sfm$JUVENILE == -1)
sfm<-sfm %>% mutate(FRAGMENT = mapvalues(FRAGMENT, c(NA), c(0)),
REMNANT = mapvalues(REMNANT, c(NA), c(0)),
JUVENILE = mapvalues(JUVENILE, c(NA), c(0)),
EX_BOUND = mapvalues(EX_BOUND, c(NA), c(0)),
NO_COLONY = mapvalues(NO_COLONY, c(NA), c(0)),
RDCAUSE1 = mapvalues(RDCAUSE1, c(""), c(NA)),
RDCAUSE2 = mapvalues(RDCAUSE2, c(""), c(NA)),
RDCAUSE3 = mapvalues(RDCAUSE3, c("NA", ""), c(NA, NA)),
CON_1 = mapvalues(CON_1, c(""), c(NA)),
CON_2 = mapvalues(CON_2, c(""), c(NA)),
CON_3 = mapvalues(CON_3, c("NA", ""), c(NA, NA)),
OLD_DEAD = mapvalues(OLD_DEAD, c(NA), c(0)))
#old dead isn't recorded for Juvs
sfm$OLD_DEAD[which(sfm$JUVENILE == -1)] <- NA
#Seglength for juvs is 1m not 2.5 CHANGE WHEN ACTUALLY DEALING WITH DATA
sfm$SEGLENGTH[which(sfm$JUVENILE == -1)] <- 1
#Add column for segment area
levels(as.factor(sfm$SEGLENGTH))
sfm$SEGAREA <- sfm$SEGLENGTH*sfm$SEGWIDTH
#Miscellaneous changes needed
sapply(sfm,unique)
length(unique(sfm$SITE)) # 103 unique sites
length(unique(sfm$site_seg)) # 391 unique site_segs
#Miscellaneous changes needed
sapply(sfm,unique)
which(sfm$SEGMENT == 10 & sfm$SITE == "PAG-1323")
sfm$SEGMENT[which(sfm$SEGMENT == 10 & sfm$SITE == "PAG-1323")] <- 5
sfm$site_seg[which(sfm$site_seg == "PAG-1323 10")] <- "PAG-1323 5"
length(unique(sfm$site_seg)) # 391 unique site_segs
which(sfm.raw$SEGMENT == 10 & sfm.raw$SITE == "PAG-1323")
v2 <- read.csv("MARAMP2022_Calibration_2022-08-25.csv")
sitelist <- read.csv("C:/Users/Jonathan.Charendoff/Documents/GitHub/Benthic-Scripts/SfM/Method Comparision/MARAMP2022_SfM_Calib_Meta.csv")[1:5,]
#Reformat v2 Site names
v2$SITE<-gsub("_", "-", v2$SITE)
levels(as.factor(v2$SITE))
#Merge v1 and v2 geodatabases together
sfm.raw <- v2
#sfm.raw <- rbind(v1,v2)
dim(sfm.raw)
# Change site numbers such as MAR-22 to MAR-0022
sfm.raw$SITE<-SiteNumLeadingZeros(sfm.raw$SITE)
View(SiteNumLeadingZeros)
View(SiteNumLeadingZeros)
sfm.raw$SITE[1]
nchar(sfm.raw$SITE[1])
nchar(sfm.raw$SITE[3])
nchar(sfm.raw$SITE[4])
nchar(sfm.raw$SITE[5])
nchar(sfm.raw$SITE[2])
sfm.raw$SITE[2]
sfm.raw$SITE[1200]
nchar(sfm.raw$SITE[1200])
sfm.raw$SEGMENT[which(sfm.raw$SEGMENT == 10 & sfm.raw$SITE == "PAG-1323")] <- 5
sfm.raw$site_seg<-paste(sfm.raw$SITE,sfm.raw$SEGMENT)
unique(sfm.raw$ANALYST)
# Check to see if any sites are missing (should have 106 sites)
sitespresent <- data.frame(unique(sfm.raw$SITE)) #Get list of sites exported from gdb
sitespresent <- sitespresent %>% filter(unique.sfm.raw.SITE.!=" " & unique.sfm.raw.SITE.!="A"
&unique.sfm.raw.SITE.!="" & unique.sfm.raw.SITE.!="RA2201") #Remove erroneous site names
sitespresent$df <- rep("present",times = nrow(sitespresent)) #Add column to differentiate from "master" site list
colnames(sitespresent) <- c("SITE", "df")
sitelist$df <- rep("expected",times = nrow(sitelist))
sites <- full_join(sitespresent,sitelist, by="SITE")
sites <- sites %>% filter(is.na(df.x) | is.na(df.y)) #Flag sites that are missing in the site list or gdb export
View(sites) # still missing 5 sites....?
seglist<-ddply(sfm.raw,.(SITE),summarize,n=length(unique(SEGMENT))) #there should be no sites that have less than 3 segments
View(seglist)
#Fill in known values if data are missing
sfm.raw$OBS_YEAR <- rep(2022, times=nrow(sfm.raw))
sfm.raw$MISSION_ID <- rep("RA2201", times=nrow(sfm.raw))
sfm.raw$SEGMENT<-as.factor(sfm.raw$SEGMENT)
table(sfm.raw$SITE,sfm.raw$SEGMENT)
#Create a dataframe that houses all rows that have not been completely filled out (not including RD and CON-related columns)
sfm.raw$ANALYST <- as.factor(sfm.raw$ANALYST)
sfm.raw$SITE <- as.factor(sfm.raw$SITE)
sfm.raw$SEGMENT <- as.factor(sfm.raw$SEGMENT)
sfm.missing.duplicate.rows <- rbind(
>>>>>>> parent of 4050125 (updates for maramp)
analyst.missing <- filter(sfm.raw, ANALYST %in% c("NA", " ")),
site.missing <- filter(sfm.raw, SITE %in% c("NA-   NA", "-   NA", "A-   NA")),
transect.missing <- filter(sfm.raw, TRANSECT %in% c(" ", "NA", "")),
seglength.missing <-filter(sfm.raw, SEGLENGTH %in% c(0.0, "0","NA")),
segwidths.missing <- filter(sfm.raw, SEGWIDTH %in% c("0", "NA", "", " ")),
spcode.missing <-  filter(sfm.raw, SPCODE %in% c("NA", " ", "")),
morphcode.missing <-  filter(sfm.raw, MORPH_CODE %in% c("NA", " ", "")),
transect.missing <-  filter(sfm.raw, TRANSECT %in% c(0, "<Null>", " ")),
segmennt.missing <-  filter(sfm.raw, SEGMENT %in% c("NA", "<NA>")))
sfm.missing <- sfm.missing.duplicate.rows[!duplicated(sfm.missing.duplicate.rows),]
dim(sfm.missing)
View(sfm.missing)
#Identify all rows where NO_COLONY_ is -1 and all values beforehand are also filled in. These values are ok and should NOT be placed in the sfm.missing dataframe
no.colony.present <- sfm.missing %>%
filter(NO_COLONY == "-1" & ANALYST != "NA" & SITE != "NA" & SEGLENGTH != "0" & SEGWIDTH != "0")
head(no.colony.present)
#Remove rows with no colony present from the sfm.missing dataframe IF they aren't missing anything else important
sfm.missing <- droplevels(anti_join(sfm.missing, no.colony.present))
dim(sfm.missing)
#If charging forward and leaving rows with missing data behind, create a new dataframe where all rows with missing data have been removed
sfm <- droplevels(anti_join(sfm.raw, sfm.missing))
nrow(sfm)
#### If some column classes = logical, Run this function that removes logical NAs ####
RemoveLogicalNA <- function(b)
{
if (is.logical(b) == "TRUE") {
b[is.logical(b)] <- "NA"
b <- as.factor(b)
}
return(b)
}
sfm$RDCAUSE_3 <- RemoveLogicalNA(sfm$RDCAUSE_3)
sfm$RD_3 <- RemoveLogicalNA(sfm$RD_3)
sfm$EXTENT_1 <- RemoveLogicalNA(sfm$EXTENT_1)
sfm$EXTENT_2 <- RemoveLogicalNA(sfm$EXTENT_2)
sfm$EXTENT_3 <- RemoveLogicalNA(sfm$EXTENT_3)
sfm$CON_2 <- RemoveLogicalNA(sfm$CON_2)
sfm$CON_3 <- RemoveLogicalNA(sfm$CON_3)
sfm$SEV_2 <- RemoveLogicalNA(sfm$SEV_2)
sfm$SEV_3 <- RemoveLogicalNA(sfm$SEV_3)
#Fix columns with incorrect factor levels
sapply(sfm,unique)
#sfm <- sfm %>% filter(SITE != "-   NA" & SITE != "SE1902-   NA") #cant find where these errors are in the gdb
sfm$OLD_DEAD <- as.numeric(sfm$OLD_DEAD)
sfm$OLD_DEAD
View(sfm)
#sfm <- sfm %>% filter(SITE != "-   NA" & SITE != "SE1902-   NA") #cant find where these errors are in the gdb
sfm$OLDDEAD <- as.numeric(sfm$OLDDEAD)
sfm<-sfm %>% mutate(FRAGMENT = mapvalues(FRAGMENT, c(NA), c(0)),
REMNANT = mapvalues(REMNANT, c(NA), c(0)),
JUVENILE = mapvalues(JUVENILE, c(NA), c(0)),
EX_BOUND = mapvalues(EX_BOUND, c(NA), c(0)),
NO_COLONY = mapvalues(NO_COLONY, c(NA), c(0)),
RDCAUSE_1 = mapvalues(RDCAUSE_1, c("NA", ""),  c(NA, NA)),
RDCAUSE_2 = mapvalues(RDCAUSE_2, c("NA", ""),  c(NA, NA)),
RDCAUSE_3 = mapvalues(RDCAUSE_3, c("NA", ""), c(NA, NA)),
RD_3 = mapvalues(RD_3, c("NA"), c(NA)),
EXTENT_2 = mapvalues(EXTENT_2, c("NA"), c(NA)),
EXTENT_3 = mapvalues(EXTENT_3, c("NA"), c(NA)),
SEV_2 = mapvalues(SEV_2, c("NA"), c(NA)),
SEV_3 = mapvalues(SEV_3, c("NA"), c(NA)),
CON_1 = mapvalues(CON_1, c("NA", ""), c(NA, NA)),
CON_2 = mapvalues(CON_2, c("NA", ""),  c(NA, NA)),
CON_3 = mapvalues(CON_3, c("NA", ""), c(NA, NA)),
<<<<<<< HEAD
OLDDEAD = mapvalues(OLDDEAD, c(NA), c(0)),
JUV_SUBSTRATE = mapvalues(JUV_SUBSTRATE, c(""), c(NA)))
sfm[which(sfm$JUVENILE == -1),"OLDDEAD"]
#old dead isn't recorded for Juvs
sfm[which(sfm$JUVENILE == -1),]
#old dead isn't recorded for Juvs
View(sfm[which(sfm$JUVENILE == -1 & sfm$OLDDEAD>0),]
)
sfm$JUVENILE[which(sfm$JUVENILE == -1 & sfm$Shape_Length >= 0.05 & sfm$SEGLENGTH > 1)]
sfm[which(sfm$JUVENILE == -1 & sfm$Shape_Length >= 0.05 & sfm$SEGLENGTH > 1),]
View(sfm[which(sfm$JUVENILE == -1 & sfm$OLDDEAD>0),])
sfm[which(sfm$JUVENILE == -1 & sfm$Shape_Length >= 0.0475 & sfm$SEGLENGTH > 1),]
v2 <- read.csv("RA2301_demographics.csv")
v2$SITE<-gsub("_", "-", v2$SITE)
#Merge v1 and v2 geodatabases together
sfm.raw <- v2
#sfm.raw <- rbind(v1,v2)
dim(sfm.raw)
# Change site numbers such as MAR-22 to MAR-0022
sfm.raw$SITE <- as.factor(sfm.raw$SITE)
sfm.raw$SITE<-SiteNumLeadingZeros(sfm.raw$SITE) ##NOT WORKING
#If not already present from running the v1-v2 merge script, add column for site_segment
#sfm.raw$SEGMENT[which(sfm.raw$SEGMENT == 10 & sfm.raw$SITE == "PAG-1323")] <- 5
#sfm.raw$SEGMENT[which(sfm.raw$SEGMENT == 10 & sfm.raw$SITE == "MAU-1222")] <- 15
sfm.raw$site_seg<-paste(sfm.raw$SITE,sfm.raw$SEGMENT)
# Check to see if any sites are missing (should have 106 sites)
sitespresent <- data.frame(unique(sfm.raw$SITE)) #Get list of sites exported from gdb
sitespresent <- sitespresent %>% filter(unique.sfm.raw.SITE.!=" " & unique.sfm.raw.SITE.!="A"
&unique.sfm.raw.SITE.!="" & unique.sfm.raw.SITE.!="RA2301") #Remove erroneous site names
sitespresent$df <- rep("present",times = nrow(sitespresent)) #Add column to differentiate from "master" site list
colnames(sitespresent) <- c("SITE", "df")
sitelist$df <- rep("expected",times = nrow(sitelist))
sitelist$SITE <- as.factor(sitelist$SITE)
sitelist$SITE <- SiteNumLeadingZeros(sitelist$SITE)
sites <- full_join(sitespresent,sitelist, by="SITE")
sites <- sites %>% filter(is.na(df.x) | is.na(df.y)) #Flag sites that are missing in the site list or gdb export
View(sites) # still missing 5 sites....?
#write.csv(sites, "HARAMP_missing_sites.csv") # MOL-2266 and HAW-4224 were dropped because they weren't completed
seglist<-ddply(sfm.raw,.(SITE),summarize,n=length(unique(SEGMENT))) #there should be no sites that have less than 3 segments
#Fill in known values if data are missing
sfm.raw$OBS_YEAR <- rep(2023, times=nrow(sfm.raw))
sfm.raw$MISSION_ID <- rep("RA2301", times=nrow(sfm.raw))
sfm.raw$SEGMENT<-as.factor(sfm.raw$SEGMENT)
table(sfm.raw$SITE,sfm.raw$SEGMENT)
#Create a dataframe that houses all rows that have not been completely filled out (not including RD and CON-related columns)
sfm.raw$ANALYST <- as.factor(sfm.raw$ANALYST)
sfm.raw$SITE <- as.factor(sfm.raw$SITE)
sfm.raw$SEGMENT <- as.factor(sfm.raw$SEGMENT)
sfm.missing.duplicate.rows <- rbind(
analyst.missing <- filter(sfm.raw, ANALYST %in% c("NA", " ")),
site.missing <- filter(sfm.raw, SITE %in% c("NA-   NA", "-   NA", "A-   NA")),
transect.missing <- filter(sfm.raw, TRANSECT %in% c(" ", "NA", "")),
seglength.missing <-filter(sfm.raw, SEGLENGTH %in% c(0.0, "0","NA")),
segwidths.missing <- filter(sfm.raw, SEGWIDTH %in% c("0", "NA", "", " ")),
spcode.missing <-  filter(sfm.raw, SPCODE %in% c("NA", " ", "")),
morphcode.missing <-  filter(sfm.raw, MORPH_CODE %in% c("NA", " ", "")),
transect.missing <-  filter(sfm.raw, TRANSECT %in% c(0, "<Null>", " ")),
segmennt.missing <-  filter(sfm.raw, SEGMENT %in% c("NA", "<NA>")))
sfm.missing <- sfm.missing.duplicate.rows[!duplicated(sfm.missing.duplicate.rows),]
dim(sfm.missing)
View(sfm.missing)
#Identify all rows where NO_COLONY_ is -1 and all values beforehand are also filled in. These values are ok and should NOT be placed in the sfm.missing dataframe
no.colony.present <- sfm.missing %>%
filter(NO_COLONY == "-1" & ANALYST != "NA" & SITE != "NA" & SEGLENGTH != "0" & SEGWIDTH != "0")
head(no.colony.present)
#Remove rows with no colony present from the sfm.missing dataframe IF they aren't missing anything else important
sfm.missing <- droplevels(anti_join(sfm.missing, no.colony.present))
dim(sfm.missing)
View(sfm.missing)
#If charging forward and leaving rows with missing data behind, create a new dataframe where all rows with missing data have been removed
sfm <- droplevels(anti_join(sfm.raw, sfm.missing))
nrow(sfm)
RemoveLogicalNA <- function(b)
{
if (is.logical(b) == "TRUE") {
b[is.logical(b)] <- "NA"
b <- as.factor(b)
}
return(b)
}
#### end function ####
#Add "NA" to columns with class = logical (whole column filled with italized, shaded "NA")
str(sfm) # no columns are logical = skip this step
sfm$RDCAUSE_3 <- RemoveLogicalNA(sfm$RDCAUSE_3)
sfm$RD_3 <- RemoveLogicalNA(sfm$RD_3)
sfm$EXTENT_1 <- RemoveLogicalNA(sfm$EXTENT_1)
sfm$EXTENT_2 <- RemoveLogicalNA(sfm$EXTENT_2)
sfm$EXTENT_3 <- RemoveLogicalNA(sfm$EXTENT_3)
sfm$CON_2 <- RemoveLogicalNA(sfm$CON_2)
sfm$CON_3 <- RemoveLogicalNA(sfm$CON_3)
sfm$SEV_2 <- RemoveLogicalNA(sfm$SEV_2)
sfm$SEV_3 <- RemoveLogicalNA(sfm$SEV_3)
#Fix columns with incorrect factor levels
sapply(sfm,unique)
#sfm <- sfm %>% filter(SITE != "-   NA" & SITE != "SE1902-   NA") #cant find where these errors are in the gdb
sfm$OLDDEAD <- as.numeric(sfm$OLDDEAD)
sfm<-sfm %>% mutate(FRAGMENT = mapvalues(FRAGMENT, c(NA), c(0)),
REMNANT = mapvalues(REMNANT, c(NA), c(0)),
JUVENILE = mapvalues(JUVENILE, c(NA), c(0)),
EX_BOUND = mapvalues(EX_BOUND, c(NA), c(0)),
NO_COLONY = mapvalues(NO_COLONY, c(NA), c(0)),
RDCAUSE_1 = mapvalues(RDCAUSE_1, c("NA", ""),  c(NA, NA)),
RDCAUSE_2 = mapvalues(RDCAUSE_2, c("NA", ""),  c(NA, NA)),
RDCAUSE_3 = mapvalues(RDCAUSE_3, c("NA", ""), c(NA, NA)),
RD_3 = mapvalues(RD_3, c("NA"), c(NA)),
EXTENT_2 = mapvalues(EXTENT_2, c("NA"), c(NA)),
EXTENT_3 = mapvalues(EXTENT_3, c("NA"), c(NA)),
SEV_2 = mapvalues(SEV_2, c("NA"), c(NA)),
SEV_3 = mapvalues(SEV_3, c("NA"), c(NA)),
CON_1 = mapvalues(CON_1, c("NA", ""), c(NA, NA)),
CON_2 = mapvalues(CON_2, c("NA", ""),  c(NA, NA)),
CON_3 = mapvalues(CON_3, c("NA", ""), c(NA, NA)),
OLDDEAD = mapvalues(OLDDEAD, c(NA), c(0)),
JUV_SUBSTRATE = mapvalues(JUV_SUBSTRATE, c(""), c(NA)))
#old dead isn't recorded for Juvs
View(sfm[which(sfm$JUVENILE == -1 & sfm$OLDDEAD>0),])
#old dead isn't recorded for Juvs
sfm$OLDDEAD[which(sfm$JUVENILE == -1 & sfm$OLDDEAD>0)]<-0
sfm[which(sfm$JUVENILE == -1),c(19,20)]
sfm[which(sfm$JUVENILE == -1 & sfm$Shape_Length >= 0.0475 & sfm$SEGLENGTH > 1),]
sfm[which(sfm$JUVENILE == -1),c(19,20)]
sfm[which(sfm$JUVENILE == -1 & sfm$RD_1>0),c(19,20)]
sfm[which(sfm$JUVENILE == -1 & sfm$RD_1>0),]
sfm$RDCAUSE_1[which(sfm$JUVENILE == -1 & sfm$RD_1>0)] <- NA
sfm$RD_1[which(sfm$JUVENILE == -1 & sfm$RD_1>0)] <- NA
sfm$RDCAUSE_1[which(sfm$JUVENILE == -1 & sfm$RD_1>0)]
sfm$RD_1[which(sfm$JUVENILE == -1 & sfm$RD_1>0)]
sfm[which(sfm$JUVENILE == -1 & sfm$Shape_Length >= 0.0475 & sfm$SEGLENGTH > 1),]
sfm$RDCAUSE_2[which(sfm$JUVENILE == -1 & sfm$RD_2>0)]
sfm$JUVENILE[which(sfm$JUVENILE == -1 & sfm$Shape_Length >= 0.0475 & sfm$SEGLENGTH > 1)] <-0
sfm$JUV_SUBSTRATE[which(sfm$JUVENILE == -1 & sfm$Shape_Length >= 0.0475 & sfm$SEGLENGTH > 1)] <-NA
sfm$SEGLENGTH[which(sfm$JUVENILE == -1& sfm$SEGLENGTH > 1)]
#Seglength for juvs is 1m not 2.5 CHANGE WHEN ACTUALLY DEALING WITH DATA
sfm[which(sfm$JUVENILE == -1& sfm$SEGLENGTH > 1),]
View(segwidths.missing)
sfm.missing.duplicate.rows <- rbind(
analyst.missing <- filter(sfm.raw, ANALYST %in% c("NA", " ",NA)),
site.missing <- filter(sfm.raw, SITE %in% c("NA-   NA", "-   NA", "A-   NA",NA)),
transect.missing <- filter(sfm.raw, TRANSECT %in% c(" ", "NA", "",NA)),
seglength.missing <-filter(sfm.raw, SEGLENGTH %in% c(0.0, "0","NA",NA)),
segwidths.missing <- filter(sfm.raw, SEGWIDTH %in% c("0", "NA", "", " ",NA)),
spcode.missing <-  filter(sfm.raw, SPCODE %in% c("NA", " ", "",NA)),
morphcode.missing <-  filter(sfm.raw, MORPH_CODE %in% c("NA", " ", "",NA)),
transect.missing <-  filter(sfm.raw, TRANSECT %in% c(0, "<Null>", " ",NA)),
segmennt.missing <-  filter(sfm.raw, SEGMENT %in% c("NA", "<NA>",NA)))
sfm.missing <- sfm.missing.duplicate.rows[!duplicated(sfm.missing.duplicate.rows),]
dim(sfm.missing)
#Identify all rows where NO_COLONY_ is -1 and all values beforehand are also filled in. These values are ok and should NOT be placed in the sfm.missing dataframe
no.colony.present <- sfm.missing %>%
filter(NO_COLONY == "-1" & ANALYST != "NA" & SITE != "NA" & SEGLENGTH != "0" & SEGWIDTH != "0")
#Remove rows with no colony present from the sfm.missing dataframe IF they aren't missing anything else important
sfm.missing <- droplevels(anti_join(sfm.missing, no.colony.present))
dim(sfm.missing)
View(sfm.missing)
sfm[which(sfm$JUVENILE == -1& sfm$SEGLENGTH > 1),]
sfm$SEGWIDTH[is.na(sfm$SEGAREA)]
sfm$SEGWIDTH[is.na(sfm$SEGWIDTH)]
sfm$SEGWIDTH[is.na(sfm$SEGWIDTH)] <-1
sfm$SEGLENGTH[which(sfm$JUVENILE == -1
)]
sfm[which(sfm$JUVENILE == -1& sfm$SEGLENGTH > 1),]
#Seglength for juvs is 1m not 2.5 CHANGE WHEN ACTUALLY DEALING WITH DATA
sfm$SEGLENGTH[which(sfm$JUVENILE == -1& sfm$SEGLENGTH > 1)] <- 1
sfm$SEGWIDTH[is.na(sfm$SEGWIDTH)] <-1
#Add column for segment area
sfm$SEGLENGTH <- as.numeric(sfm$SEGLENGTH)
sfm$SEGWIDTH <- as.numeric(sfm$SEGWIDTH)
sfm$SEGAREA <- sfm$SEGLENGTH*sfm$SEGWIDTH
#Miscellaneous changes needed
sapply(sfm,unique)
length(unique(sfm$SITE)) # 103 unique sites
length(unique(sfm$site_seg)) # 391 unique site_segs
colnames(sfm)[c(19,21,23)] <- c("RDCAUSE1", "RDCAUSE2", "RDCAUSE3")
View(sfm)
# QC Checks -------------------------------------------------------------------------------------
#Set up output csv file that reports the status of the qc checks
output<-data.frame(
QC_check<-character(),
Status<-character(),stringsAsFactors = FALSE)
#1. Check if only part of a site-segment was removed and placed in the sfm.missing dataframe while the other part was placed in the sfm dataframe. Remove these site-segments.
partial_SiteSeg_removal <- inner_join(sfm.missing, sfm, by = c("SITE", "SEGMENT"))
head(partial_SiteSeg_removal) # a dataframe with no data will be displayed if site-segment pairs were NOT split between missing and populated dataframes = good
unique(partial_SiteSeg_removal$SITE)
v2 <- read.csv("RA2301_demographics.csv")
sitelist <- na.omit(read.csv("C:/Users/Jonathan.Charendoff/Documents/GitHub/Benthic-Scripts/SfM/Method Comparision/ASRAMP2023_SfM_Meta.csv"))
# Prep the v2 geodatabase data -----------------------------------------------------
# # Merge annotator geodatabases together (all are v2 geodatabase)
#
# dim(MA); dim(ML); dim(AH); dim(RS); dim(CA); dim(FL)
# str(MA); str(ML); str(AH); str(RS); str(CA); str(FL)
#
# sfm.raw <- rbind(MA, ML, AH, RS, CA, FL, v1, stringsAsFactors = FALSE)
#Reformat v2 Site names
v2$SITE<-gsub("_", "-", v2$SITE)
#Merge v1 and v2 geodatabases together
sfm.raw <- v2
#sfm.raw <- rbind(v1,v2)
dim(sfm.raw)
# Change site numbers such as MAR-22 to MAR-0022
sfm.raw$SITE <- as.factor(sfm.raw$SITE)
sfm.raw$SITE<-SiteNumLeadingZeros(sfm.raw$SITE) ##NOT WORKING
#If not already present from running the v1-v2 merge script, add column for site_segment
#sfm.raw$SEGMENT[which(sfm.raw$SEGMENT == 10 & sfm.raw$SITE == "PAG-1323")] <- 5
#sfm.raw$SEGMENT[which(sfm.raw$SEGMENT == 10 & sfm.raw$SITE == "MAU-1222")] <- 15
sfm.raw$site_seg<-paste(sfm.raw$SITE,sfm.raw$SEGMENT)
# Check to see if any sites are missing (should have 106 sites)
sitespresent <- data.frame(unique(sfm.raw$SITE)) #Get list of sites exported from gdb
sitespresent <- sitespresent %>% filter(unique.sfm.raw.SITE.!=" " & unique.sfm.raw.SITE.!="A"
&unique.sfm.raw.SITE.!="" & unique.sfm.raw.SITE.!="RA2301") #Remove erroneous site names
sitespresent$df <- rep("present",times = nrow(sitespresent)) #Add column to differentiate from "master" site list
colnames(sitespresent) <- c("SITE", "df")
sitelist$df <- rep("expected",times = nrow(sitelist))
sitelist$SITE <- as.factor(sitelist$SITE)
sitelist$SITE <- SiteNumLeadingZeros(sitelist$SITE)
sites <- full_join(sitespresent,sitelist, by="SITE")
sites <- sites %>% filter(is.na(df.x) | is.na(df.y)) #Flag sites that are missing in the site list or gdb export
View(sites) # still missing 5 sites....?
#write.csv(sites, "HARAMP_missing_sites.csv") # MOL-2266 and HAW-4224 were dropped because they weren't completed
seglist<-ddply(sfm.raw,.(SITE),summarize,n=length(unique(SEGMENT))) #there should be no sites that have less than 3 segments
#Fill in known values if data are missing
sfm.raw$OBS_YEAR <- rep(2023, times=nrow(sfm.raw))
sfm.raw$MISSION_ID <- rep("RA2301", times=nrow(sfm.raw))
sfm.raw$SEGMENT<-as.factor(sfm.raw$SEGMENT)
table(sfm.raw$SITE,sfm.raw$SEGMENT)
#Create a dataframe that houses all rows that have not been completely filled out (not including RD and CON-related columns)
sfm.raw$ANALYST <- as.factor(sfm.raw$ANALYST)
sfm.raw$SITE <- as.factor(sfm.raw$SITE)
sfm.raw$SEGMENT <- as.factor(sfm.raw$SEGMENT)
sfm.missing.duplicate.rows <- rbind(
analyst.missing <- filter(sfm.raw, ANALYST %in% c("NA", " ",NA)),
site.missing <- filter(sfm.raw, SITE %in% c("NA-   NA", "-   NA", "A-   NA",NA)),
transect.missing <- filter(sfm.raw, TRANSECT %in% c(" ", "NA", "",NA)),
seglength.missing <-filter(sfm.raw, SEGLENGTH %in% c(0.0, "0","NA",NA)),
segwidths.missing <- filter(sfm.raw, SEGWIDTH %in% c("0", "NA", "", " ",NA)),
spcode.missing <-  filter(sfm.raw, SPCODE %in% c("NA", " ", "",NA)),
morphcode.missing <-  filter(sfm.raw, MORPH_CODE %in% c("NA", " ", "",NA)),
transect.missing <-  filter(sfm.raw, TRANSECT %in% c(0, "<Null>", " ",NA)),
segmennt.missing <-  filter(sfm.raw, SEGMENT %in% c("NA", "<NA>",NA)))
sfm.missing <- sfm.missing.duplicate.rows[!duplicated(sfm.missing.duplicate.rows),]
dim(sfm.missing)
#Identify all rows where NO_COLONY_ is -1 and all values beforehand are also filled in. These values are ok and should NOT be placed in the sfm.missing dataframe
no.colony.present <- sfm.missing %>%
filter(NO_COLONY == "-1" & ANALYST != "NA" & SITE != "NA" & SEGLENGTH != "0" & SEGWIDTH != "0")
#Remove rows with no colony present from the sfm.missing dataframe IF they aren't missing anything else important
sfm.missing <- droplevels(anti_join(sfm.missing, no.colony.present))
dim(sfm.missing)
#If charging forward and leaving rows with missing data behind, create a new dataframe where all rows with missing data have been removed
sfm <- droplevels(anti_join(sfm.raw, sfm.missing))
RemoveLogicalNA <- function(b)
{
if (is.logical(b) == "TRUE") {
b[is.logical(b)] <- "NA"
b <- as.factor(b)
}
return(b)
}
#### end function ####
#Add "NA" to columns with class = logical (whole column filled with italized, shaded "NA")
str(sfm) # no columns are logical = skip this step
sfm$RDCAUSE_3 <- RemoveLogicalNA(sfm$RDCAUSE_3)
sfm$RD_3 <- RemoveLogicalNA(sfm$RD_3)
sfm$EXTENT_1 <- RemoveLogicalNA(sfm$EXTENT_1)
sfm$EXTENT_2 <- RemoveLogicalNA(sfm$EXTENT_2)
sfm$EXTENT_3 <- RemoveLogicalNA(sfm$EXTENT_3)
sfm$CON_2 <- RemoveLogicalNA(sfm$CON_2)
sfm$CON_3 <- RemoveLogicalNA(sfm$CON_3)
sfm$SEV_2 <- RemoveLogicalNA(sfm$SEV_2)
sfm$SEV_3 <- RemoveLogicalNA(sfm$SEV_3)
#Fix columns with incorrect factor levels
sapply(sfm,unique)
#sfm <- sfm %>% filter(SITE != "-   NA" & SITE != "SE1902-   NA") #cant find where these errors are in the gdb
sfm$OLDDEAD <- as.numeric(sfm$OLDDEAD)
sfm<-sfm %>% mutate(FRAGMENT = mapvalues(FRAGMENT, c(NA), c(0)),
REMNANT = mapvalues(REMNANT, c(NA), c(0)),
JUVENILE = mapvalues(JUVENILE, c(NA), c(0)),
EX_BOUND = mapvalues(EX_BOUND, c(NA), c(0)),
NO_COLONY = mapvalues(NO_COLONY, c(NA), c(0)),
RDCAUSE_1 = mapvalues(RDCAUSE_1, c("NA", ""),  c(NA, NA)),
RDCAUSE_2 = mapvalues(RDCAUSE_2, c("NA", ""),  c(NA, NA)),
RDCAUSE_3 = mapvalues(RDCAUSE_3, c("NA", ""), c(NA, NA)),
RD_3 = mapvalues(RD_3, c("NA"), c(NA)),
EXTENT_2 = mapvalues(EXTENT_2, c("NA"), c(NA)),
EXTENT_3 = mapvalues(EXTENT_3, c("NA"), c(NA)),
SEV_2 = mapvalues(SEV_2, c("NA"), c(NA)),
SEV_3 = mapvalues(SEV_3, c("NA"), c(NA)),
CON_1 = mapvalues(CON_1, c("NA", ""), c(NA, NA)),
CON_2 = mapvalues(CON_2, c("NA", ""),  c(NA, NA)),
CON_3 = mapvalues(CON_3, c("NA", ""), c(NA, NA)),
OLDDEAD = mapvalues(OLDDEAD, c(NA), c(0)),
JUV_SUBSTRATE = mapvalues(JUV_SUBSTRATE, c(""), c(NA)))
sfm$OLDDEAD[which(sfm$JUVENILE == -1 & sfm$OLDDEAD>0)]
sfm$RDCAUSE_1[which(sfm$JUVENILE == -1 & sfm$RD_1>0)]
#dead isn't recorded for Juvs
#sfm[which(sfm$JUVENILE == -1 & sfm$OLDDEAD>0),]
sfm$RDCAUSE_1[which(sfm$JUVENILE == -1 & sfm$RD_1>0)] <- NA
sfm$RD_1[which(sfm$JUVENILE == -1 & sfm$RD_1>0)] <- NA
sfm$JUVENILE[which(sfm$JUVENILE == -1 & sfm$Shape_Length >= 0.0475 & sfm$SEGLENGTH > 1)]
sfm$JUV_SUBSTRATE[which(sfm$JUVENILE == -1 & sfm$Shape_Length >= 0.0475 & sfm$SEGLENGTH > 1)]
sfm$SEGLENGTH[which(sfm$JUVENILE == -1& sfm$SEGLENGTH > 1)]
sfm$SEGWIDTH[is.na(sfm$SEGWIDTH)]
unique(as.numeric(sfm$SEGLENGTH))
unique(as.numeric(sfm$SEGWIDTH))
#Add column for segment area
sfm$SEGLENGTH <- as.numeric(sfm$SEGLENGTH)
sfm$SEGWIDTH <- as.numeric(sfm$SEGWIDTH)
sfm$SEGAREA <- sfm$SEGLENGTH*sfm$SEGWIDTH
#Miscellaneous changes needed
sapply(sfm,unique)
length(unique(sfm$SITE)) # 103 unique sites
length(unique(sfm$site_seg)) # 391 unique site_segs
colnames(sfm)[c(19,21,23)] <- c("RDCAUSE1", "RDCAUSE2", "RDCAUSE3")
output<-data.frame(
QC_check<-character(),
Status<-character(),stringsAsFactors = FALSE)
#1. Check if only part of a site-segment was removed and placed in the sfm.missing dataframe while the other part was placed in the sfm dataframe. Remove these site-segments.
partial_SiteSeg_removal <- inner_join(sfm.missing, sfm, by = c("SITE", "SEGMENT"))
head(partial_SiteSeg_removal)
partial_SiteSeg_removal <- droplevels(partial_SiteSeg_removal)
unique(partial_SiteSeg_removal$SITE)
output[1,] <- c("Sites have been completely annotated", "YES") #change depending on previous lines of code
#2.Check that the columns have the appropripate type of data (e.g. numeric vs. text) & no errant codes (e.g. SEV and/or RD columns contain NA)
sapply(sfm,levels)
str(sfm)
sfm$CON_2 <- as.character(sfm$CON_2)
sfm$CON_3 <- as.character(sfm$CON_3)
sfm$SEV_2 <- as.numeric(sfm$SEV_2)
sfm$SEV_3 <- as.numeric(sfm$SEV_3)
sapply(sfm, class)
str(sfm)
sfm$EXTENT_2 <- as.numeric(sfm$EXTENT_2)
sfm$EXTENT_3 <- as.numeric(sfm$EXTENT_3)
str(sfm)
sapply(sfm, class)
output[2,]<-c("No errant codes", "some logical NAs and blanks throughout -- ok")
# #3. All TRANSECT within v2 of the geodabase should = A (B is for repeats)
filter(sfm, TRANSECT != "A")
output[2,]<-c("No errant codes", "ok")
output[3,]<-c("All transects = A","ok") #change depending on output from previous lines of code
#4. Make sure that if NO_COLONY=-1 none of the following columns have been populated
sfm %>% filter(sfm$SPCODE == "NA" & sfm$NO_COLONY != -1)
sfm %>% filter(sfm$SPCODE != "NA" & sfm$NO_COLONY == -1)
sfm[sfm$SPCODE != "" & sfm$NO_COLONY == -1,]
sfm[which(sfm$SPCODE != "" & sfm$NO_COLONY == -1),]
sfm[which(sfm$SPCODE == "" & sfm$NO_COLONY == -1),]
sfm[which(sfm$SPCODE == ""),]
View(sfm[which(sfm$SPCODE == ""),])
sfm<-sfm %>% mutate(FRAGMENT = mapvalues(FRAGMENT, c(NA), c(0)),
REMNANT = mapvalues(REMNANT, c(NA), c(0)),
JUVENILE = mapvalues(JUVENILE, c(NA), c(0)),
EX_BOUND = mapvalues(EX_BOUND, c(NA), c(0)),
NO_COLONY = mapvalues(NO_COLONY, c(NA), c(0)),
SPCODE = mapvalues(SPCODE, c(""), c(NA)),
MORPH_CODE = mapvalues(MORPH_CODE, c(""), c(NA)),
RDCAUSE_1 = mapvalues(RDCAUSE_1, c("NA", ""),  c(NA, NA)),
RDCAUSE_2 = mapvalues(RDCAUSE_2, c("NA", ""),  c(NA, NA)),
RDCAUSE_3 = mapvalues(RDCAUSE_3, c("NA", ""), c(NA, NA)),
RD_3 = mapvalues(RD_3, c("NA"), c(NA)),
EXTENT_2 = mapvalues(EXTENT_2, c("NA"), c(NA)),
EXTENT_3 = mapvalues(EXTENT_3, c("NA"), c(NA)),
SEV_2 = mapvalues(SEV_2, c("NA"), c(NA)),
SEV_3 = mapvalues(SEV_3, c("NA"), c(NA)),
CON_1 = mapvalues(CON_1, c("NA", ""), c(NA, NA)),
CON_2 = mapvalues(CON_2, c("NA", ""),  c(NA, NA)),
CON_3 = mapvalues(CON_3, c("NA", ""), c(NA, NA)),
OLDDEAD = mapvalues(OLDDEAD, c(NA), c(0)),
JUV_SUBSTRATE = mapvalues(JUV_SUBSTRATE, c(""), c(NA)))
sfm <- droplevels(anti_join(sfm.raw, sfm.missing))
nrow(sfm)
#### If some column classes = logical, Run this function that removes logical NAs ####
RemoveLogicalNA <- function(b)
{
if (is.logical(b) == "TRUE") {
b[is.logical(b)] <- "NA"
b <- as.factor(b)
}
return(b)
}
#### end function ####
#Add "NA" to columns with class = logical (whole column filled with italized, shaded "NA")
str(sfm) # no columns are logical = skip this step
sfm$RDCAUSE_3 <- RemoveLogicalNA(sfm$RDCAUSE_3)
sfm$RD_3 <- RemoveLogicalNA(sfm$RD_3)
sfm$EXTENT_1 <- RemoveLogicalNA(sfm$EXTENT_1)
sfm$EXTENT_2 <- RemoveLogicalNA(sfm$EXTENT_2)
sfm$EXTENT_3 <- RemoveLogicalNA(sfm$EXTENT_3)
sfm$CON_2 <- RemoveLogicalNA(sfm$CON_2)
sfm$CON_3 <- RemoveLogicalNA(sfm$CON_3)
sfm$SEV_2 <- RemoveLogicalNA(sfm$SEV_2)
sfm$SEV_3 <- RemoveLogicalNA(sfm$SEV_3)
#Fix columns with incorrect factor levels
sapply(sfm,unique)
#sfm <- sfm %>% filter(SITE != "-   NA" & SITE != "SE1902-   NA") #cant find where these errors are in the gdb
sfm$OLDDEAD <- as.numeric(sfm$OLDDEAD)
sfm<-sfm %>% mutate(FRAGMENT = mapvalues(FRAGMENT, c(NA), c(0)),
REMNANT = mapvalues(REMNANT, c(NA), c(0)),
JUVENILE = mapvalues(JUVENILE, c(NA), c(0)),
EX_BOUND = mapvalues(EX_BOUND, c(NA), c(0)),
NO_COLONY = mapvalues(NO_COLONY, c(NA), c(0)),
SPCODE = mapvalues(SPCODE, c(""), c(NA)),
MORPH_CODE = mapvalues(MORPH_CODE, c(""), c(NA)),
RDCAUSE_1 = mapvalues(RDCAUSE_1, c("NA", ""),  c(NA, NA)),
RDCAUSE_2 = mapvalues(RDCAUSE_2, c("NA", ""),  c(NA, NA)),
RDCAUSE_3 = mapvalues(RDCAUSE_3, c("NA", ""), c(NA, NA)),
RD_3 = mapvalues(RD_3, c("NA"), c(NA)),
EXTENT_2 = mapvalues(EXTENT_2, c("NA"), c(NA)),
EXTENT_3 = mapvalues(EXTENT_3, c("NA"), c(NA)),
SEV_2 = mapvalues(SEV_2, c("NA"), c(NA)),
SEV_3 = mapvalues(SEV_3, c("NA"), c(NA)),
CON_1 = mapvalues(CON_1, c("NA", ""), c(NA, NA)),
CON_2 = mapvalues(CON_2, c("NA", ""),  c(NA, NA)),
CON_3 = mapvalues(CON_3, c("NA", ""), c(NA, NA)),
OLDDEAD = mapvalues(OLDDEAD, c(NA), c(0)),
JUV_SUBSTRATE = mapvalues(JUV_SUBSTRATE, c(""), c(NA)))
sfm$RDCAUSE_1[which(sfm$JUVENILE == -1 & sfm$RD_1>0)] <- NA
sfm$RD_1[which(sfm$JUVENILE == -1 & sfm$RD_1>0)] <- NA
#sfm[which(sfm$JUVENILE == -1 & sfm$Shape_Length >= 0.0475 & sfm$SEGLENGTH > 1),]
#Seglength for juvs is 1m not 2.5 CHANGE WHEN ACTUALLY DEALING WITH DATA
#sfm$SEGLENGTH[which(sfm$JUVENILE == -1& sfm$SEGLENGTH > 1)] <- 1
#sfm$SEGWIDTH[is.na(sfm$SEGWIDTH)] <-1
#Add column for segment area
sfm$SEGLENGTH <- as.numeric(sfm$SEGLENGTH)
sfm$SEGWIDTH <- as.numeric(sfm$SEGWIDTH)
sfm$SEGAREA <- sfm$SEGLENGTH*sfm$SEGWIDTH
=======
OLD_DEAD = mapvalues(OLD_DEAD, c(NA), c(0)))
#old dead isn't recorded for Juvs
sfm$OLD_DEAD[which(sfm$JUVENILE == -1)] <- NA
#Seglength for juvs is 1m not 2.5 CHANGE WHEN ACTUALLY DEALING WITH DATA
sfm$SEGLENGTH[which(sfm$JUVENILE == -1)] <- 1
#Add column for segment area
levels(as.factor(sfm$SEGLENGTH))
sfm$SEGAREA <- sfm$SEGLENGTH*sfm$SEGWIDTH
View(sfm)
>>>>>>> parent of 4050125 (updates for maramp)
#Miscellaneous changes needed
sapply(sfm,unique)
length(unique(sfm$SITE)) # 103 unique sites
length(unique(sfm$site_seg)) # 391 unique site_segs
<<<<<<< HEAD
colnames(sfm)[c(19,21,23)] <- c("RDCAUSE1", "RDCAUSE2", "RDCAUSE3")
=======
# QC Checks -------------------------------------------------------------------------------------
#Set up output csv file that reports the status of the qc checks
output<-data.frame(
QC_check<-character(),
Status<-character(),stringsAsFactors = FALSE)
#1. Check if only part of a site-segment was removed and placed in the sfm.missing dataframe while the other part was placed in the sfm dataframe. Remove these site-segments.
partial_SiteSeg_removal <- inner_join(sfm.missing, sfm, by = c("SITE", "SEGMENT"))
head(partial_SiteSeg_removal) # a dataframe with no data will be displayed if site-segment pairs were NOT split between missing and populated dataframes = good
partial_SiteSeg_removal <- droplevels(partial_SiteSeg_removal)
unique(partial_SiteSeg_removal$SITE)
output[,1] <- c("Sites have been completely annotated", "YES") #change depending on previous lines of code
View(output)
#2.Check that the columns have the appropripate type of data (e.g. numeric vs. text) & no errant codes (e.g. SEV and/or RD columns contain NA)
sapply(sfm,levels)
str(sfm)
sapply(sfm, class)
output[2,]<-c("No errant codes", "some logical NAs and blanks throughout -- ok")
>>>>>>> parent of 4050125 (updates for maramp)
#4. Make sure that if NO_COLONY=-1 none of the following columns have been populated
sfm %>% filter(sfm$SPCODE == "NA" & sfm$NO_COLONY != -1)
sfm %>% filter(sfm$SPCODE != "NA" & sfm$NO_COLONY == -1)
sfm %>% filter(sfm$FRAGMENT == -1 & sfm$NO_COLONY == -1)
sfm %>% filter(sfm$REMNANT == -1 & sfm$NO_COLONY == -1)
sfm %>% filter(sfm$MORPH_CODE == "NA" & sfm$NO_COLONY != -1)
sfm %>% filter(sfm$MORPH_CODE != "NA" & sfm$NO_COLONY == -1)
output[4,]<-c("NO_COLONY segments filled correctly","YES")
<<<<<<< HEAD
#5. Calculate the number of annotated segments per site and check that all segments contain both seglengths (except segment 15)
##Create a summary table of #segments per site and check against tracking data sheet
seg.per.site <- ddply(sfm,.(SITE, SEGMENT, SEGLENGTH), summarize, num.annotated = n_distinct(SEGLENGTH))
eval.seg.per.site <- as.data.frame(acast(seg.per.site, SITE~SEGMENT, length))
#eval.seg.per.site$Total <- rowSums(eval.seg.per.site)
View(eval.seg.per.site)
sfm[sfm$SITE == "BAK-02050",]
View(sfm[sfm$SITE == "BAK-02050",])
getwd
getwd()
#use this file to evaluate where segments may be missing
write.csv(eval.seg.per.site, "2023_Missing_seg_eval.csv")
=======
output[1,] <- c("Sites have been completely annotated", "YES") #change depending on previous lines of code
#5. Calculate the number of annotated segments per site and check that all segments contain both seglengths (except segment 15)
##Create a summary table of #segments per site and check against tracking data sheet
seg.per.site <- ddply(sfm,.(SITE, SEGMENT, SEGLENGTH), summarize, num.annotated = n_distinct(SEGLENGTH))
View(seg.per.site)
eval.seg.per.site <- as.data.frame(acast(seg.per.site, SITE~SEGMENT, length))
View(eval.seg.per.site)
#eval.seg.per.site$Total <- rowSums(eval.seg.per.site)
View(eval.seg.per.site)
output[5,]<-c("All annotated segments have correct #seglengths","23 sites don't have 15m seglength") #change depending on output from previous line of code
#7.Check for incorrect species-V:\PHOTOMOSAIC (1)\HARAMP\HARAMP_2019_codes.csv
ddply(sfm,.(SPCODE),summarize,temp=length(SPCODE))
which(sfm$SPCODE =="SYSP")
which(sfm$SPCODE =="GPLA")
sfm[1222,]
sfm$SPCODE[which(sfm$SPCODE == "SYSP")] <-"STSP"
sfm$SPCODE[which(sfm$SPCODE == "GPLA")] <-"GEDW"
which(sfm$SPCODE =="AHYA")
sfm[455,]
sfm[which(sfm$SPCODE =="ACSP"),]
sfm$SPCODE[which(sfm$SPCODE == "AHYA")] <-"ACSP"
output[7,]<-c("Species codes are correct","Some NA and blank -- OK")
#8. Check that SEGWIDTH is correct (should have been apparent in qc #1).
levels(as.factor(sfm$SEGAREA)) #should all be 1 OR 2.5, unless otherwise stated
output[8,]<-c("All segment widths are correct","YES") #change depending on output from previous line of code
#9. Identify colonies flagged as Juveniles or Adults, but have the innocorrect segment area. make sure j = 1 and A = 2.5
sm.colonies.eval <- sfm %>% filter(JUVENILE== -1,SEGAREA != 1); sm.colonies.eval
lg.colonies.eval <- sfm %>% filter(JUVENILE==0,SEGAREA==1, NO_COLONY==0); lg.colonies.eval
output[9,]<-c("Juveniles and Adult colonies have correct labeling", "YES")
#10. Identify colonies have the same CON code across multiple CON columns
sfm$CON_3 <- as.factor(sfm$CON_3)
CON_dup <- sfm %>% filter(CON_1!="NA") %>% filter(CON_2!="NA")
levels(CON_dup$CON_1) # come up with complete list of codes used in CON column
levels(CON_dup$CON_2)
levels(CON_dup$CON_3)
#10. Identify colonies have the same CON code across multiple CON columns
sfm$CON_3 <- as.character(sfm$CON_3)
CON_dup <- sfm %>% filter(CON_1!="NA") %>% filter(CON_2!="NA")
levels(CON_dup$CON_1) # come up with complete list of codes used in CON column
levels(CON_dup$CON_2)
levels(CON_dup$CON_3)
CON_dup$CON_1 <-factor(CON_dup$CON_1, levels=
c("ALG", "BLE","BLP"," ","NA","DAMG" ,"DIS" ,"FUG","PRS","PTR" ,"SGA","TIN"))
CON_dup$CON_2 <-factor(CON_dup$CON_2, levels=
c("ALG", "BLE","BLP"," " ,"NA","DAMG" ,"DIS" ,"FUG","PRS","PTR" ,"SGA","TIN")) #Give columns the full list of codes used in the dataaset
CON_dup$CON_3 <-factor(CON_dup$CON_3, levels=
c("ALG", "BLE","BLP", " " ,"NA","DAMG" ,"DIS" ,"FUG","PRS","PTR" ,"SGA","TIN"))
CON_check1 <- CON_dup %>% filter(CON_1==CON_2);nrow(CON_check1) # extract rows with duplicate levels among CON_1,2, and 3
CON_check2 <- CON_dup %>% filter(CON_1==CON_3);nrow(CON_check2)
CON_check3 <- CON_dup %>% filter(CON_2==CON_3);nrow(CON_check3)
output[10,]<-c("Corals do not have duplicate CON codes","YES")
#11. Identify colonies that have the same RDCAUSE code across multiple RDCAUSE columns
sfm$RDCAUSE3 <- as.factor(sfm$RDCAUSE3)
RD_dup <- sfm %>% filter(RDCAUSE1!="NA") %>% filter(RDCAUSE2!="NA")
levels(RD_dup$RDCAUSE1) # come up with complete list of codes used in RD column
levels(RD_dup$RDCAUSE2)
levels(RD_dup$RDCAUSE3)
RD_dup$RDCAUSE1 <-factor(RD_dup$RDCAUSE1, levels= c("CIL","COTS" ,"DAMG", "DZGN", "FISH" ,"GAST","MACA"," ",
"NA","OVRG","PRED","SEDI","TLS" ,"TUNI","UNKN"))
RD_dup$RDCAUSE2 <-factor(RD_dup$RDCAUSE2, levels= c("CIL","COTS" ,"DAMG", "DZGN", "FISH" ,"GAST","MACA"," ",
"NA","OVRG","PRED","SEDI","TLS" ,"TUNI","UNKN")) #Give columns the full list of codes used in the dataaset
RD_dup$RDCAUSE3 <-factor(RD_dup$RDCAUSE3, levels= c("CIL","COTS" ,"DAMG", "DZGN", "FISH" ,"GAST", "MACA"," ",
"NA","OVRG","PRED","SEDI","TLS" ,"TUNI","UNKN"))
RD_check1 <- RD_dup %>% filter(RDCAUSE1==RDCAUSE2);nrow(RD_check1) # extract rows with duplicate levels among RDCAUSE1,2, and 3
RD_check2 <- RD_dup %>% filter(RDCAUSE1==RDCAUSE3);nrow(RD_check2) # should be empty
RD_check3 <- RD_dup %>% filter(RDCAUSE2==RDCAUSE3);nrow(RD_check3)
output[11,]<-c("Corals do not have duplicate RD codes","YES")
#12. Identify colonies with 0% recent dead, but has an RDCAUSE code - This check should result in 0 records
a<-sfm[sfm$RD_1== 0 & sfm$RDCAUSE1!="NA",]; unique(a$site_seg)
unique(a$site_seg)
sfm[sfm$RD_2=="0" & sfm$RDCAUSE2!= NA,]
#12. Identify colonies with 0% recent dead, but has an RDCAUSE code - This check should result in 0 records
a<-sfm[sfm$RD_1== 0 & sfm$RDCAUSE1!=NA,]; unique(a$site_seg)
sfm[sfm$RD_1== 0 & sfm$RDCAUSE1!=NA,]
View(a)
#12. Identify colonies with 0% recent dead, but has an RDCAUSE code - This check should result in 0 records
a<-sfm[which(sfm$RD_1== 0 & sfm$RDCAUSE1!=NA),]; unique(a$site_seg)
sfm[which(sfm$RD_2=="0" & sfm$RDCAUSE2!= NA),]
sfm[which(sfm$RD_3=="0"& sfm$RDCAUSE3!= NA),]
output[12,]<-c("0% Recent Dead corals do NOT have an RDCAUSE code","YES")
#13. Identify colonies with recent dead >0%, but there is no RDCAUSE code - This check should result in 0 records
sfm[which(sfm$RD_1 >0 & sfm$RDCAUSE1==NA),] #,rowSums(is.na(sfm)) != ncol(sfm),]
sfm[which(sfm$RD_2 >0 & sfm$RDCAUSE2==NA),] #,rowSums(is.na(a)) != ncol(a), ]
sfm[which(sfm$RD_3 >0 & sfm$RDCAUSE3==NA),] #,rowSums(is.na(a)) != ncol(a), ]
output[13,]<-c("All corals with RD >0 have an RDCAUSE code","YES")
#14. Identify colonies with NO % EXTENT, but a condition - This check should result in 0 records
sfm[which(sfm$EXTENT_1=="0"& sfm$CON_1!=NA),]
sfm[which(sfm$EXTENT_2=="0"& sfm$CON_2!=NA),]
a<-sfm[which(sfm$EXTENT_3=="0"& sfm$CON_3!=NA),]
sfm[which(sfm$EXTENT_3=="0"& sfm$CON_3!=NA),]
#15. Identify colonies that have no condition, but a value in extent - This check should result in 0 records
sfm[which(sfm$CON_1==NA& sfm$EXTENT_1!=0),]
sfm[which(sfm$CON_2==NA& sfm$EXTNET_2!=0),]
sfm[which(sfm$CON_3==NA& sfm$EXTENT_3!=0),] #rowSums(is.na(a)) != ncol(a),]
#15. Identify colonies that have no condition, but a value in extent - This check should result in 0 records
sfm[which(sfm$CON_1!=NA& sfm$EXTENT_1!=0),]
which(sfm$CON_1!=NA & sfm$EXTENT_1!=0)
which(sfm$CON_1!=NA)
which(sfm$CON_1!="NA")
sfm[which(sfm$RD_1== 0 & sfm$RDCAUSE1!="NA"),]#; unique(a$site_seg)
sfm[which(sfm$RD_2=="0" & sfm$RDCAUSE2!= "NA"),]
sfm[which(sfm$RD_3=="0"& sfm$RDCAUSE3!= "NA"),]
#13. Identify colonies with recent dead >0%, but there is no RDCAUSE code - This check should result in 0 records
sfm[which(sfm$RD_1 >0 & sfm$RDCAUSE1=="NA"),] #,rowSums(is.na(sfm)) != ncol(sfm),]
sfm[which(sfm$RD_2 >0 & sfm$RDCAUSE2=="NA"),] #,rowSums(is.na(a)) != ncol(a), ]
sfm[which(sfm$RD_3 >0 & sfm$RDCAUSE3=="NA"),] #,rowSums(is.na(a)) != ncol(a), ]
#14. Identify colonies with NO % EXTENT, but a condition - This check should result in 0 records
sfm[which(sfm$EXTENT_1=="0"& sfm$CON_1!="NA"),]
sfm[which(sfm$EXTENT_2=="0"& sfm$CON_2!="NA"),]
sfm[which(sfm$EXTENT_3=="0"& sfm$CON_3!="NA"),]
#15. Identify colonies that have no condition, but a value in extent - This check should result in 0 records
sfm[which(sfm$CON_1!="NA" & sfm$EXTENT_1!=0),]
#15. Identify colonies that have no condition, but a value in extent - This check should result in 0 records
sfm[which(sfm$CON_1=="NA" & sfm$EXTENT_1!=0),]
sfm[which(sfm$CON_2=="NA" & sfm$EXTNET_2!=0),]
sfm[which(sfm$CON_3=="NA" & sfm$EXTENT_3!=0),] #rowSums(is.na(a)) != ncol(a),]
output[15,]<-c("All colonies with NO condition also have NO extent","YES")
which(sfm$EXTENT_1!="0")
which(sfm$EXTENT_1!=0)
#16. Identify colonies with nothing in condition column, but a value in severity. Double check that these shouldn't be 0
sfm[which(sfm$EXTENT_1=="0"& sfm$SEV_1!="0"),] #,rowSums(is.na(a)) != ncol(a),]
sfm[which(sfm$EXTENT_2=="0"& sfm$SEV_2!="0"),]
sfm[which(sfm$EXTENT_3=="0"& sfm$SEV_3!="0"),]
output[16,]<-c("All colonies with NO extent have NO severity","YES")
#17. Make sure that the only rows with severity filled contain BLE or BLP in condition
sfm[which(sfm$SEV_1=="0"& sfm$CON_1 %in% c("BLE","BLP")),]
sfm[which(sfm$SEV_2=="0"& sfm$CON_2%in% c("BLE","BLP")),]
sfm[which(sfm$SEV_3=="0"& sfm$CON_3%in% c("BLE","BLP")),]
sfm$CON_1 %in% c("BLE","BLP")
which(sfm$CON_1 %in% c("BLE","BLP"))
which(sfm$CON_2 %in% c("BLE","BLP"))
`%notin%` <- Negate(`%in%`)
sfm[which(sfm$SEV_1!="0"& sfm$CON_1 %notin% c("BLE","BLP")),]
sfm[which(sfm$SEV_2!="0"& sfm$CON_2 %notin% c("BLE","BLP")),]
sfm[which(sfm$SEV_3!="0"& sfm$CON_3 %notin% c("BLE","BLP")),]
output[17,]<-c("Severity value is present only in colonies with CON = BLE and BLP", "YES")
output[14,]<-c("All colonies with a condition have an extent", "YES")
#18. Make sure that values in SEV are only 0,1,2, or 3
sfm[sfm$SEV_1>3,]
#18. Make sure that values in SEV are only 0,1,2, or 3
sfm[which(sfm$SEV_1>3),]
sfm[which(sfm$SEV_2>3),]
sfm[which(sfm$SEV_3>3),]
#18. Make sure that values in SEV are only 0,1,2, or 3
sfm[which(sfm$SEV_1>3 | sfm$SEV_1<2),]
sfm[which(sfm$SEV_2>3 | sfm$SEV_1<2),]
sfm[which(sfm$SEV_3>3 | sfm$SEV_1<2),]
output[18,]<-c("Severity values are whole numbers between 0-3","YES")
#19. Check if there are any EX_BOUND colonies that have a conspicuously small seglength
sfm[sfm$EX_BOUND == "-1"& sfm$Shape_Leng < 0.25,]
#19. Check if there are any EX_BOUND colonies that have a conspicuously small seglength
sfm[which(sfm$EX_BOUND == "-1"& sfm$Shape_Leng < 0.25),]
which(sfm$EX_BOUND == "-1"
)
sfm$EX_BOUND[which(sfm$EX_BOUND == "-1"),]
sfm[which(sfm$EX_BOUND == "-1"),]
#19. Check if there are any EX_BOUND colonies that have a conspicuously small shape length
sfm$EX_BOUND[which(sfm$EX_BOUND == "-1"& sfm$Shape_Length < 0.25),] <- 0
#19. Check if there are any EX_BOUND colonies that have a conspicuously small shape length
sfm$EX_BOUND[which(sfm$EX_BOUND == "-1"& sfm$Shape_Length < 0.25)] <- 0
#19. Check if there are any EX_BOUND colonies that have a conspicuously small shape length
sfm[which(sfm$EX_BOUND == "-1"& sfm$Shape_Length < 0.25),]
#20. RD + OD is not greater than 100%
sfm$OLDDEAD<-as.numeric(sfm$OLDDEAD)
#20. RD + OD is not greater than 100%
sfm$OLD_DEAD<-as.numeric(sfm$OLD_DEAD)
sfm$RD_2<-as.numeric(sfm$RD_2)
sfm$RD_1<-as.numeric(sfm$RD_1)
sfm$RD_3<-as.numeric(sfm$RD_3)
sfm$totaldead = sfm$RD_1+sfm$RD_2+sfm$RD_3 + sfm$OLDDEAD
sfm$totaldead = sfm$RD_1+sfm$RD_2+sfm$RD_3 + sfm$OLD_DEAD
sfm[sfm$totaldead>100,] #RD + OD can equal 100, but not >100
sfm[which(sfm$totaldead>100),] #RD + OD can equal 100, but not >100
output[20,]<-c("RD + OD <=100%","YES")
#21. Check for duplicate rows in dataframe - it may be ok that colonies are exactly the same length
a<-sfm %>% group_by(Shape_Leng,site_seg) %>% filter(n()>1)
#21. Check for duplicate rows in dataframe - it may be ok that colonies are exactly the same length
a<-sfm %>% group_by(Shape_Length,site_seg) %>% filter(n()>1)
View(a)
sfm %>% group_by(Shape_Length,site_seg) %>% filter(n()>1)
output[21,]<-c("No duplicate rows","1 potential duplicate")
#22. Make sure that if a coral is a remnant, that SEGLENGTH = 2.5 regardless of max diameter
remnant.seglegth <- sfm %>% filter(REMNANT == "-1" & SEGLENGTH != 2.5)
View(remnant.seglegth)
remnant.olddead <- sfm %>% filter(REMNANT == "-1" & OLD_DEAD != 0)
View(remnant.olddead)
#23. Make sure that if a coral is a juvenile, they don't have a value in OLDDEAD, or any RD or CON columns
juv.olddead <- sfm %>% filter(JUVENILE == "-1" & OLD_DEAD != 0 | JUVENILE == "-1" & CON_1 != "NA" |
JUVENILE == "-1" & CON_2 != "NA" | JUVENILE == "-1" & CON_3 != "NA" |
JUVENILE == "-1" & RDCAUSE1 != "NA" |JUVENILE == "-1" & RDCAUSE2 != "NA" |
JUVENILE == "-1" & RDCAUSE3 != "NA"); nrow(juv.olddead)
remnant.error <- rbind(remnant.seglegth,remnant.olddead); nrow(remnant.error)
View(remnant.error)
which(sfm$REMNANT == "-1" & SFM$SEGLENGTH != 2.5)
sfm %>% filter(REMNANT == "-1" & SEGLENGTH != 2.5)
which(sfm$REMNANT == -1 & SFM$SEGLENGTH != 2.5)
which(sfm$REMNANT == -1 & sfm$SEGLENGTH != 2.5)
sfm$SEGLENGTH[which(sfm$REMNANT == -1 & sfm$SEGLENGTH != 2.5)] <- 2.5
#22. Make sure that if a coral is a remnant, that SEGLENGTH = 2.5 regardless of max diameter
remnant.seglegth <- sfm %>% filter(REMNANT == "-1" & SEGLENGTH != 2.5)
sfm$SEGAREA <- sfm$SEGLENGTH*sfm$SEGWIDTH
which(sfm$REMNANT == -1 & & OLD_DEAD != 0)
which(sfm$REMNANT == -1 & OLD_DEAD != 0)
which(sfm$REMNANT == -1 & sfm$OLD_DEAD != 0)
sfm$OLD_DEAD[which(sfm$REMNANT == -1 & sfm$OLD_DEAD != 0)] <- NA
remnant.olddead <- sfm %>% filter(REMNANT == "-1" & OLD_DEAD != 0)
remnant.error <- rbind(remnant.seglegth,remnant.olddead); nrow(remnant.error)
sfm$OLD_DEAD[which(sfm$REMNANT == -1 & sfm$OLD_DEAD != 0)] <- 0 #fix olddead error
output[22,]<-c("REMNANT filled out correctly","YES")
#23. Make sure that if a coral is a juvenile, they don't have a value in OLDDEAD, or any RD or CON columns
juv.olddead <- sfm %>% filter(JUVENILE == "-1" & OLD_DEAD != 0 | JUVENILE == "-1" & CON_1 != "NA" |
JUVENILE == "-1" & CON_2 != "NA" | JUVENILE == "-1" & CON_3 != "NA" |
JUVENILE == "-1" & RDCAUSE1 != "NA" |JUVENILE == "-1" & RDCAUSE2 != "NA" |
JUVENILE == "-1" & RDCAUSE3 != "NA"); nrow(juv.olddead)
output[23,]<-c("Juvenile colonies have no OLDDEAD, RD, or CON","YES")
sfm$OLD_DEAD[which(sfm$REMNANT == -1 & sfm$OLD_DEAD != 0)] <- NA #fix olddead error
#Export QC output table with appropriate file name
write.csv(output,"MARAMP2022_sfm_Calib_output.csv")
sfm$COLONYID<-c(1:length(sfm$OID_))
View(sfm)
#Separate by adults and juveniles
ad<-subset(sfm,JUVENILE==0|REMNANT==-1)
ad<-subset(ad,select=-c(OID_,totaldead,SEGAREA))
j<-subset(sfm,JUVENILE=="-1") # includes segments where NO_COLONY = -1
j<-subset(j,select=c(COLONYID,ANALYST,OBS_YEAR,MISSION_ID,SITE,TRANSECT,SEGMENT,SEGLENGTH,SEGWIDTH,NO_COLONY,SPCODE,FRAGMENT,MORPH_CODE,
EX_BOUND,JUVENILE,FRAGMENT,REMNANT,Shape_Leng,SEGAREA))
View(j)
j<-subset(j,select=c(COLONYID,ANALYST,OBS_YEAR,MISSION_ID,SITE,TRANSECT,SEGMENT,SEGLENGTH,SEGWIDTH,NO_COLONY,SPCODE,FRAGMENT,MORPH_CODE,
EX_BOUND,JUVENILE,FRAGMENT,REMNANT,Shape_Length,SEGAREA))
ad_e<-ddply(ad,.(SITE),summarize,n=length(unique(SEGMENT)))
View(ad_e)
#Export QC'd data
#Data ends up in "T:/Benthic/Data/SfM/QC" NOT within Benthic-Scripts Github folder
# setwd('T:/Benthic/Data/SfM/QC/')
write.csv(ad,"MARAMP2022_QCdsfm_ADULT_CALIB.csv",row.names = F)
write.csv(j,"MARAMP2022_QCdsfm_JUV_CALIB.csv",row.names = F)
write.csv(sfm,"MARAMP2022_output_FINAL_CALIB.csv",row.names = F)
#Set Run Flags
DEBUG=TRUE
#LOAD LIBRARY FUNCTIONS ...
source("C:/Users/Jonathan.Charendoff/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_newApp_vTAOfork.R")
source("C:/Users/Jonathan.Charendoff/Documents/GitHub/fish-paste/lib/core_functions.R")
# SFM/ADULT: CLEAN ANALYSIS READY DATA ----------------------------------------------------
df<-read.csv("T:/Benthic/Data/SfM/Calibration QC/MARAMP2022_QCdsfm_ADULT_CALIB.csv")
x<-df
head(x)
View(x)
nrow(x)
#SfM/ADULT: Column Names Changes -------------------------------------------------
colnames(x)[colnames(x)=="RD_1"]<-"RDEXTENT1" #Change column name
colnames(x)[colnames(x)=="RDCAUSE1"]<-"RD1" #Change column name
colnames(x)[colnames(x)=="RD_2"]<-"RDEXTENT2" #Change column name
colnames(x)[colnames(x)=="RD_3"]<-"RDEXTENT3" #Change column name
colnames(x)[colnames(x)=="RDCAUSE2"]<-"RD2" #Change column name
colnames(x)[colnames(x)=="RDCAUSE3"]<-"RD3" #Change column name
colnames(x)[colnames(x)=="FRAGMENT_Y"]<-"Fragment" #Change column name
colnames(x)[colnames(x)=="CON_1"]<-"CONDITION_1" #Change column name
colnames(x)[colnames(x)=="CON_2"]<-"CONDITION_2" #Change column name
colnames(x)[colnames(x)=="CON_3"]<-"CONDITION_3" #Change column name
colnames(x)[colnames(x)=="SEV_1"]<-"SEVERITY_1" #Change column name
colnames(x)[colnames(x)=="SEV_2"]<-"SEVERITY_2" #Change column name
colnames(x)[colnames(x)=="SEV_3"]<-"SEVERITY_3" #Change column name
colnames(x)[colnames(x)=="SHAPE_Length"]<-"COLONYLENGTH" #Change column name
colnames(x)[colnames(x)=="OID_"]<-"COLONYID" #Change column name
#Add column for method type
x$METHOD<-"SfM"
if(DEBUG){head(x)}
table(x$SITE,x$ANALYST)
#Fill in columns with values that we know should not be different across any of the rows
x$OBS_YEAR <- as.vector(rep(2022, times = nrow(x)))
x$COLONYLENGTH<-x$COLONYLENGTH*100 #convert from m to cm
colnames(x)[colnames(x)=="Shape_Length"]<-"COLONYLENGTH" #Change column name
x$COLONYLENGTH<-x$COLONYLENGTH*100 #convert from m to cm
x$S_ORDER<-ifelse(x$NO_COLONY_==0 & x$SPCODE!="NONE","Scleractinia","NONE") #add S_order column
x$S_ORDER<-ifelse(x$NO_COLONY_==0 | x$SPCODE!="NONE","Scleractinia","NONE") #add S_order column
x$S_ORDER<-ifelse(x$NO_COLONY==0 | x$SPCODE!="NONE","Scleractinia","NONE") #add S_order column
#Create Genuscode and taxonname column from spcode
genlookup<-read.csv("T:/Benthic/Data/Lookup Tables/Genus_lookup.csv")
x<-CreateGenusCode(x,genlookup)
head(x)
#Generate General RD cause code
gencodes<-read.csv("T:/Benthic/Data/Lookup Tables/GeneralRDcode_lookup.csv")
levels(x$RD1)
x$RD1 <- as.factor(x$RD1)
x$RD1 <- as.factor(x$RD2)
x$RD1 <- as.factor(x$RD3)
levels(x$RD1)
df<-read.csv("T:/Benthic/Data/SfM/Calibration QC/MARAMP2022_QCdsfm_ADULT_CALIB.csv")
x<-df
head(x)
View(x)
nrow(x)
#SfM/ADULT: Column Names Changes -------------------------------------------------
colnames(x)[colnames(x)=="RD_1"]<-"RDEXTENT1" #Change column name
colnames(x)[colnames(x)=="RDCAUSE1"]<-"RD1" #Change column name
colnames(x)[colnames(x)=="RD_2"]<-"RDEXTENT2" #Change column name
colnames(x)[colnames(x)=="RD_3"]<-"RDEXTENT3" #Change column name
colnames(x)[colnames(x)=="RDCAUSE2"]<-"RD2" #Change column name
colnames(x)[colnames(x)=="RDCAUSE3"]<-"RD3" #Change column name
colnames(x)[colnames(x)=="FRAGMENT_Y"]<-"Fragment" #Change column name
colnames(x)[colnames(x)=="CON_1"]<-"CONDITION_1" #Change column name
colnames(x)[colnames(x)=="CON_2"]<-"CONDITION_2" #Change column name
colnames(x)[colnames(x)=="CON_3"]<-"CONDITION_3" #Change column name
colnames(x)[colnames(x)=="SEV_1"]<-"SEVERITY_1" #Change column name
colnames(x)[colnames(x)=="SEV_2"]<-"SEVERITY_2" #Change column name
colnames(x)[colnames(x)=="SEV_3"]<-"SEVERITY_3" #Change column name
colnames(x)[colnames(x)=="Shape_Length"]<-"COLONYLENGTH" #Change column name
colnames(x)[colnames(x)=="OID_"]<-"COLONYID" #Change column name
#Add column for method type
x$METHOD<-"SfM"
if(DEBUG){head(x)}
table(x$SITE,x$ANALYST)
x$OBS_YEAR <- as.vector(rep(2022, times = nrow(x)))
x$COLONYLENGTH<-x$COLONYLENGTH*100 #convert from m to cm
x$S_ORDER<-ifelse(x$NO_COLONY==0 | x$SPCODE!="NONE","Scleractinia","NONE") #add S_order column
#I manually removed the bleaching severity 1 colonies - ifelse wasn't working
#Create Genuscode and taxonname column from spcode
genlookup<-read.csv("T:/Benthic/Data/Lookup Tables/Genus_lookup.csv")
x<-CreateGenusCode(x,genlookup)
head(x)
unique(x$RD1)
unique(x$RD2)
unique(x$RD3)
>>>>>>> parent of 4050125 (updates for maramp)
