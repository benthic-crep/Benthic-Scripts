#Modify Analysis Year
site_data$ANALYSIS_YEAR<-site_data$OBS_YEAR
site_data$OBS_YEAR<-ifelse(site_data$OBS_YEAR %in% c("2014","2015")& site_data$REGION=="NWHI", "2014-15",as.character(site_data$OBS_YEAR))
return(site_data)
}
## POOLING FUNCTIONS TO GENERATE ESTIMATES #######
#STRATA ROLL UP FUNCTION-This function calculates mean, var, SE and CV at the strata level. I've built in flexilbity to use either genus or taxoncode
# You can input any metric you would like (eg. adult density, mean % old dead,etc). Note that for any metric that does not involve density of colonies,
# Y._h (total colony abundance in stratum),varY._h (variance in total abundance), SE_Y._h and CV_Y._h are meaningless-DO NOT USE
#Note: for whatever reason, the grouping, other and metric fields need to be in this order. If you don't want to include an other field then add "DUMMY" as the second variable when you are running this function.
#e.g. st<-Calc_Strata(data.mon,"GENUS_CODE","DUMMY","ColDen")
Calc_Strata=function(site_data,grouping_field,metric_field,pres.abs_field="Adpres.abs",M_hi=250){
#Build in flexibility to look at genus or taxon level
site_data$GROUP<-site_data[,grouping_field]
#Build in flexibility to summarized different metrics
site_data$METRIC<-site_data[,metric_field]
site_data$METRIC<-as.numeric(site_data$METRIC)
site_data$PRES.ABS<-site_data[,pres.abs_field]
#For a Given ANALYSIS_SCHEMA, we need to pool N_h, and generate w_h
strat.temp<-ddply(subset(site_data,GROUP=="SSSS"),.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA,NH),summarize,temp=sum(NH,na.rm=TRUE)) #calculate # of possible sites in a given stratum
Strata_NH<-ddply(strat.temp,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA),summarize,N_h.as=sum(NH,na.rm=TRUE)) #calculate # of possible sites in a given stratum
Dom_NH<-ddply(Strata_NH,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA),summarize,Dom_N_h=sum(N_h.as,na.rm=TRUE))#calculate # of possible sites in a given domain, use this to calculate weighting factor
Strata_NH<-left_join(Strata_NH,Dom_NH) #add Dom_N_h into Strata_NH df
Strata_NH$w_h.as<-Strata_NH$N_h.as/Strata_NH$Dom_N_h # add schema weighting factor to schema dataframe
#Now add back the Analysis_Schema Dom_N_h, Nh and wh to site_data - can't use match because we need to merge based on analysis scheme and analysis year
site_data<-left_join(site_data,Strata_NH)
#Calculate summary metrics at the stratum level (rolled up from site level)
Strata_roll=ddply(site_data,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA,REEF_ZONE,DB_RZ,GROUP,Dom_N_h),summarize,
n_h=length(SITE),# No. of Sites surveyed in a Strata
N_h=median(N_h.as,na.rm=T),# Strata Area (as N 50x50 grids) - median allows you to pick 1 value
w_h=median(w_h.as,na.rm=T),# weigting factor for a given stratum- median allows you to pick 1 value
D._h=mean(METRIC,na.rm=T), # Mean of Site-Level metric in a Stratum
S1_h=var(METRIC,na.rm=T), #sample variance in metric between sites
varD._h=(1-(n_h/N_h))*S1_h/n_h, #Strata level  variance of mean density
nmtot=(N_h*250), #total possible area
th=10, #minimum sampling unit
Y._h=D._h*nmtot*th,#total colony abundance in stratum **corrected using diones code
varY._h=((nmtot^2)*varD._h*(th^2)), #variance in total abundance- corrected using diones code
SE_D._h=sqrt(varD._h),
CV_D._h=(SE_D._h/D._h)*100,
SE_Y._h=sqrt(varY._h),
CV_Y._h=(SE_Y._h/Y._h)*100,
avp=sum(PRES.ABS)/n_h,
var_prop=(n_h/(n_h-1)*avp*(1-avp)),
SEprop=sqrt(var_prop))
Strata_roll$M_hi=250 #define total possible transects in a site
Strata_roll=Strata_roll[,c("REGION","ISLAND","ANALYSIS_YEAR","DOMAIN_SCHEMA","ANALYSIS_SCHEMA","REEF_ZONE","DB_RZ","GROUP",
"M_hi","n_h","N_h","w_h",
"D._h","S1_h","varD._h","SE_D._h","CV_D._h",
"Y._h","varY._h","SE_Y._h","CV_Y._h","avp","var_prop","SEprop")]
#remove strata that have only 1 site because you can't calculate variance
Strata_roll<-Strata_roll[Strata_roll$n_h>1,]
colnames(Strata_roll)[which(colnames(Strata_roll) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
colnames(Strata_roll)[which(colnames(Strata_roll) == 'prop.occur')] <- pres.abs_field #change group to whatever your grouping field is.
return(Strata_roll)
}
#This function is very similar to Calc_Strata, but calculates the Domain NH by adding up all possible strata in a domain rather than just the ones that were sampled to calculate
#total domain area and strata weights
#This is an older function so make sure it's up to date with changes that have been made to rest of script
# Calc_Analysis_Strata=function(site_data,sec,grouping_field,metric_field,pres.abs_field="Adpres.abs",M_hi=250){
#
#   #Build in flexibility to look at genus or taxon level
#   site_data$GROUP<-site_data[,grouping_field]
#
#   #Build in flexibility to summarized different metrics
#   site_data$METRIC<-site_data[,metric_field]
#   site_data$METRIC<-as.numeric(site_data$METRIC)
#
#   site_data$PRES.ABS<-site_data[,pres.abs_field]
#
#   #For a Given ANALYSIS_SCHEMA, we need to pool N_h, and generate w_h
#   strat.temp<-ddply(subset(site_data,GROUP=="SSSS"),.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA,NH),summarize,temp=sum(NH,na.rm=TRUE)) #calculate # of possible sites in a given stratum
#   Strata_NH<-ddply(strat.temp,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA),summarize,N_h=sum(NH,na.rm=TRUE)) #calculate # of possible sites in a given stratum
#   Dom_NH<-ddply(sec,.(DOMAIN_SCHEMA),summarize,Dom_N_h=sum(NH,na.rm=TRUE))#calculate # of possible sites in a given domain (entire domain even if you didn't sample some of the strata), use this to calculate weighting factor
#   Strata_NH$Dom_N_h<-Dom_NH$Dom_N_h[match(Strata_NH$DOMAIN_SCHEMA,Dom_NH$DOMAIN_SCHEMA)]# add Dom_N_h to schema dataframe
#   Strata_NH$w_h<-Strata_NH$N_h/Strata_NH$Dom_N_h # add schema weighting factor to schema dataframe
#
#   #Now add back the Analysis_Schema Nh and wh to site_data
#   site_data$N_h.as<-Strata_NH$N_h[match(site_data$ANALYSIS_SCHEMA,Strata_NH$ANALYSIS_SCHEMA)]
#   site_data$w_h.as<-Strata_NH$w_h[match(site_data$ANALYSIS_SCHEMA,Strata_NH$ANALYSIS_SCHEMA)]
#   site_data$Dom_N_h<-Strata_NH$Dom_N_h[match(site_data$ANALYSIS_SCHEMA,Strata_NH$ANALYSIS_SCHEMA)]
#
#   #Calculate summary metrics at the stratum level (rolled up from site level)
#   Strata_roll=ddply(site_data,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA,GROUP,Dom_N_h),summarize,
#                     n_h=length(SITE),# No. of Sites surveyed in a Strata
#                     N_h=median(N_h.as,na.rm=T),# Strata Area (as N 50x50 grids) - median allows you to pick 1 value
#                     w_h=median(w_h.as,na.rm=T),# weigting factor for a given stratum- median allows you to pick 1 value
#                     D._h=mean(METRIC,na.rm=T), # Mean of Site-Level metric in a Stratum
#                     S1_h=var(METRIC,na.rm=T), #sample variance in metric between sites
#                     varD._h=(1-(n_h/N_h))*S1_h/n_h, #Strata level  variance of mean density
#                     nmtot=(N_h*250), #total possible area
#                     th=10, #minimum sampling unit
#                     Y._h=D._h*nmtot*th,#total colony abundance in stratum **corrected using diones code
#                     varY._h=((nmtot^2)*varD._h*(th^2)), #variance in total abundance- corrected using diones code
#                     SE_D._h=sqrt(varD._h),
#                     CV_D._h=(SE_D._h/D._h)*100,
#                     SE_Y._h=sqrt(varY._h),
#                     CV_Y._h=(SE_Y._h/Y._h)*100,
#                     avp=sum(PRES.ABS)/n_h,
#                     var_prop=(n_h/(n_h-1)*avp*(1-avp)),
#                     SEprop=sqrt(var_prop))
#
#   Strata_roll$M_hi=250 #define total possible transects in a site
#   Strata_roll=Strata_roll[,c("REGION","ISLAND","ANALYSIS_YEAR","DOMAIN_SCHEMA","ANALYSIS_SCHEMA","GROUP","Dom_N_h",
#                              "M_hi","n_h","N_h","w_h",
#                              "D._h","S1_h","varD._h","SE_D._h","CV_D._h",
#                              "Y._h","varY._h","SE_Y._h","CV_Y._h","avp","var_prop","SEprop")]
#
#   #remove strata that have only 1 site because you can't calculate variance
#   Strata_roll<-Strata_roll[Strata_roll$n_h>1,]
#
#   colnames(Strata_roll)[which(colnames(Strata_roll) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
#   colnames(Strata_roll)[which(colnames(Strata_roll) == 'prop.occur')] <- pres.abs_field #change group to whatever your grouping field is.
#
#
#   return(Strata_roll)
# }
#DOMAIN ROLL UP FUNCTION-This function calculates mean, var, SE and CV at the DOMAIN level. I've built in flexilbity to use either genus or taxoncode as well as other metrics (size class, morph)
# You can input any metric you would like (eg. adult density, mean % old dead,etc). Note that for any metric that does not involve density of colonies,
# Y._h (total colony abundance in stratum),varY._h (variance in total abundance), SE_Y._h and CV_Y._h are meaningless-DO NOT USE
Calc_Domain=function(site_data,grouping_field="S_ORDER",metric_field,pres.abs_field="Adpres.abs"){
Strata_data=Calc_Strata(site_data,grouping_field,metric_field,pres.abs_field)
#Build in flexibility to look at genus or taxon level
Strata_data$GROUP<-Strata_data[,grouping_field]
DomainStr_NH=ddply(subset(Strata_data,GROUP=="SSSS"),.(REGION,ANALYSIS_YEAR,DOMAIN_SCHEMA),summarize,DomainSumN_h=sum(N_h,na.rm=TRUE)) #total possible sites in a domain
Strata_data<-left_join(Strata_data, DomainStr_NH)# add previous to strata data
Strata_data$w_h=Strata_data$N_h/Strata_data$DomainSumN_h
Domain_roll=ddply(Strata_data,.(REGION,ANALYSIS_YEAR,DOMAIN_SCHEMA,GROUP),summarize,
D._st=sum(w_h*D._h,na.rm=TRUE), #Domain weighted estimate (sum of Weighted strata density)
varD._st=sum(w_h^2*varD._h,na.rm=TRUE), #Domain weighted variance estimate
Y._st=sum(Y._h,na.rm=TRUE), #Domain total abundance (sum of extrapolated strata abundance)
varY._st=sum(varY._h,na.rm=TRUE),#Domain variance total abundance (sum of extrapolated strata varaiance abundance)
n=sum(n_h,na.rm=TRUE), #total sites surveyed in domain
Ntot=sum(N_h,na.rm=TRUE), #total possible sites in domain
SE_D._st=sqrt(varD._st), #SE of domain metric estimate
CV_D._st=(SE_D._st/D._st)*100, #CV of domain metric estimate
SE_Y._st=sqrt(varY._st),#SE of domain abundance estimate
CV_Y._st=(SE_Y._st/Y._st)*100,#CV of domain abundnace estimate
po._st=sum(w_h*avp,na.rm=TRUE), #Domain weighted estimate
varpo._st=sum(w_h^2*var_prop,na.rm=TRUE), #Domain weighted variance estimate
SE_po._st=sqrt(varpo._st), #SE of domain metric estimate
CV_po._st=SE_po._st/po._st) #CV of domain metric estimate
#need to double check calculations with Dione
# Domain_roll=Domain_roll[,c("REGION","ISLAND","ANALYSIS_YEAR","DOMAIN_SCHEMA","GROUP",
#                            "n","Ntot","D._st","SE_D._st")]
#
colnames(Domain_roll)[which(colnames(Domain_roll) == 'D._st')] <- paste0("Mean","_",metric_field)
colnames(Domain_roll)[which(colnames(Domain_roll) == 'SE_D._st')] <- paste0("SE","_",metric_field)
colnames(Domain_roll)[which(colnames(Domain_roll) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
return(Domain_roll)
}
# Calc_Analysis_Domain=function(site_data,sec,grouping_field="S_ORDER",metric_field,pres.abs_field="Adpres.abs"){
#
#   Strata_data=Calc_Analysis_Strata(site_data,sec,grouping_field,metric_field,pres.abs_field)
#
#   #Build in flexibility to look at genus or taxon level
#   Strata_data$GROUP<-Strata_data[,grouping_field]
#
#   Domain_roll=ddply(Strata_data,.(ANALYSIS_YEAR,DOMAIN_SCHEMA,GROUP),summarize,
#                     D._st=sum(w_h*D._h,na.rm=TRUE), #Domain weighted estimate (sum of Weighted strata density)
#                     varD._st=sum(w_h^2*varD._h,na.rm=TRUE), #Domain weighted variance estimate
#                     Y._st=sum(Y._h,na.rm=TRUE), #Domain total abundance (sum of extrapolated strata abundance)
#                     varY._st=sum(varY._h,na.rm=TRUE),#Domain variance total abundance (sum of extrapolated strata varaiance abundance)
#                     n=sum(n_h,na.rm=TRUE), #total sites surveyed in domain
#                     Ntot=median(Dom_N_h),
#                     SE_D._st=sqrt(varD._st), #SE of domain metric estimate
#                     CV_D._st=(SE_D._st/D._st)*100, #CV of domain metric estimate
#                     SE_Y._st=sqrt(varY._st),#SE of domain abundance estimate
#                     CV_Y._st=(SE_Y._st/Y._st)*100,#CV of domain abundnace estimate
#                     po._st=sum(w_h*avp,na.rm=TRUE), #Domain weighted estimate
#                     varpo._st=sum(w_h^2*var_prop,na.rm=TRUE), #Domain weighted variance estimate
#                     SE_po._st=sqrt(varpo._st), #SE of domain metric estimate
#                     CV_po._st=SE_po._st/po._st) #CV of domain metric estimate
#
#   #need to double check calculations with Dione
#   # Domain_roll=Domain_roll[,c("REGION","ISLAND","ANALYSIS_YEAR","DOMAIN_SCHEMA","GROUP",
#   #                            "n","Ntot","D._st","SE_D._st")]
#   #
#   colnames(Domain_roll)[which(colnames(Domain_roll) == 'D._st')] <- paste0("Mean","_",metric_field)
#   colnames(Domain_roll)[which(colnames(Domain_roll) == 'SE_D._st')] <- paste0("SE","_",metric_field)
#   colnames(Domain_roll)[which(colnames(Domain_roll) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
#
#
#   return(Domain_roll)
# }
#
###POOLING FUNCTIONS FOR COVER and Richness DATA----
#need to eventually modify this code to summarize tier 2 and 3 data
Calc_Strata_Cover_Rich=function(site_data,metric_field=c("CORAL","CCA","MA","TURF","Richness"),M_hi=250){
#Build in flexibility to summarized different metrics
site_data$METRIC<-site_data[,metric_field]
site_data$METRIC<-as.numeric(site_data$METRIC)
#For a Given ANALYSIS_SCHEMA, we need to pool N_h, and generate w_h
strat.temp<-ddply(site_data,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA,NH),summarize,temp=sum(NH,na.rm=TRUE)) #calculate # of possible sites in a given stratum
Strata_NH<-ddply(strat.temp,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA),summarize,N_h=sum(NH,na.rm=TRUE)) #calculate # of possible sites in a given stratum
Dom_NH<-ddply(Strata_NH,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA),summarize,Dom_N_h=sum(N_h,na.rm=TRUE))#calculate # of possible sites in a given domain
Strata_NH$Dom_N_h<-Dom_NH$Dom_N_h[match(Strata_NH$DOMAIN_SCHEMA,Dom_NH$DOMAIN_SCHEMA)]# add Dom_N_h to schema dataframe
Strata_NH$w_h<-Strata_NH$N_h/Strata_NH$Dom_N_h # add schema weighting factor to schema dataframe
#Now add back the Analysis_Schema Nh and wh to site_data
site_data$N_h.as<-Strata_NH$N_h[match(site_data$ANALYSIS_SCHEMA,Strata_NH$ANALYSIS_SCHEMA)]
site_data$w_h.as<-Strata_NH$w_h[match(site_data$ANALYSIS_SCHEMA,Strata_NH$ANALYSIS_SCHEMA)]
#Calculate summary metrics at the stratum level (rolled up from site level)
Strata_roll=ddply(site_data,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA,REEF_ZONE,DB_RZ),summarize,
n_h=length(SITE),# No. of Sites surveyed in a Strata
N_h=median(N_h.as,na.rm=T),# Strata Area (as N 50x50 grids) - median allows you to pick 1 value
w_h=median(w_h.as,na.rm=T),# weigting factor for a given stratum- median allows you to pick 1 value
D._h=mean(METRIC,na.rm=T), # Mean of Site-Level metric in a Stratum
S1_h=var(METRIC,na.rm=T), #sample variance in metric between sites
varD._h=(1-(n_h/N_h))*S1_h/n_h, #Strata level  variance of mean density
SE_D._h=sqrt(varD._h),
CV_D._h=SE_D._h/D._h)
Strata_roll$M_hi=250 #define total possible transects in a site
Strata_roll=Strata_roll[,c("REGION","ISLAND","ANALYSIS_YEAR","DOMAIN_SCHEMA","ANALYSIS_SCHEMA","REEF_ZONE","DB_RZ",
"M_hi","n_h","N_h","w_h",
"D._h","S1_h","varD._h","SE_D._h","CV_D._h")]
#remove strata that have only 1 site because you can't calculate variance
Strata_roll<-Strata_roll[Strata_roll$n_h>1,]
return(Strata_roll)
}
Calc_Domain_Cover_Rich=function(site_data,metric_field=c("CORAL","CCA","MA","TURF","Richness")){
Strata_data=Calc_Strata_Cover_Rich(site_data,metric_field)
DomainStr_NH=ddply(Strata_data,GROUP=="SSSS",.(ANALYSIS_YEAR,DOMAIN_SCHEMA),summarize,DomainSumN_h=sum(N_h,na.rm=TRUE)) #total possible sites in a domain
Strata_data<-merge(Strata_data, DomainStr_NH,by=c("ANALYSIS_YEAR","DOMAIN_SCHEMA"))# add previous to strata data
Strata_data$w_h=Strata_data$N_h/Strata_data$DomainSumN_h
Domain_roll=ddply(Strata_data,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA),summarize,
D._st=sum(w_h*D._h,na.rm=TRUE), #Domain weighted estimate (sum of Weighted strata density)
varD._st=sum(w_h^2*varD._h,na.rm=TRUE), #Domain weighted variance estimate
n=sum(n_h,na.rm=TRUE), #total sites surveyed in domain
nstrat=length(n_h), #total number of strata in a domain
Ntot=sum(N_h,na.rm=TRUE), #total possible sites in domain
SE_D._st=sqrt(varD._st), #SE of domain metric estimate
CV_D._st=SE_D._st/D._st) #CV of domain metric estimate
Domain_roll=Domain_roll[,c("REGION","ISLAND","ANALYSIS_YEAR","DOMAIN_SCHEMA",
"n","Ntot","D._st","SE_D._st")]
colnames(Domain_roll)[which(colnames(Domain_roll) == 'D._st')] <- paste0("Mean","_",metric_field)
colnames(Domain_roll)[which(colnames(Domain_roll) == 'SE_D._st')] <- paste0("SE","_",metric_field)
return(Domain_roll)
}
###POOLING FUNCTIONS FOR PREVALENCE DATA----
#STRATA ROLL UP FUNCTION-This function calculates mean, var, SE and CV at the strata level. I've built in flexilbity to use either genus or taxoncode
# You can input any RD cause or condition metric you would like .
Calc_Strata_Prevalence=function(site_data,grouping_field,metric_field){
#Build in flexibility to look at genus or taxon level
site_data$GROUP<-site_data[,grouping_field]
#Build in flexibility to summarized different metrics
site_data$METRIC<-site_data[,metric_field]
site_data$METRIC<-as.numeric(site_data$METRIC)
#For a Given ANALYSIS_SCHEMA, we need to pool N_h, and generate w_h
strat.temp<-ddply(subset(site_data,GROUP=="SSSS"),.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA,NH),summarize,temp=sum(NH,na.rm=TRUE)) #calculate # of possible sites in a given stratum
Strata_NH<-ddply(strat.temp,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA),summarize,N_h.as=sum(NH,na.rm=TRUE)) #calculate # of possible sites in a given stratum
Dom_NH<-ddply(Strata_NH,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA),summarize,Dom_N_h=sum(N_h.as,na.rm=TRUE))#calculate # of possible sites in a given domain, use this to calculate weighting factor
Strata_NH<-left_join(Strata_NH,Dom_NH) #add Dom_N_h into Strata_NH df
Strata_NH$w_h.as<-Strata_NH$N_h.as/Strata_NH$Dom_N_h # add schema weighting factor to schema dataframe
#Now add back the Analysis_Schema Dom_N_h, Nh and wh to site_data - can't use match because we need to merge based on analysis scheme and analysis year
site_data<-left_join(site_data,Strata_NH)
#Calculate summary metrics at the stratum level (rolled up from site level)
Strata_roll=ddply(site_data,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,ANALYSIS_SCHEMA,REEF_ZONE,DB_RZ,GROUP),summarize,
n_h=length(SITE),# No. of Sites surveyed in a Strata
N_h=median(N_h.as,na.rm=T),# Strata Area (as N 50x50 grids) - median allows you to pick 1 value
w_h=median(w_h.as,na.rm=T),# weigting factor for a given stratum- median allows you to pick 1 value
C_h=mean(METRIC,na.rm=T), # Mean density colonies with specific RD cause or condition in a Stratum
S1C_h=var(METRIC,na.rm=T), #sample variance in RD cause or condition density between sites
varC_h=(1-(n_h/N_h))*S1C_h/n_h, #Strata level  variance of mean condition density
nmtot=(N_h*250), #total possible area
th=10, #minimum sampling unit
C_abun_h=C_h*nmtot*th, # abundance of colonies with a condition in stratum
varC_abun_h=((nmtot^2)*varC_h*(th^2)), #variance in total abundance of condition
SE_C_abun_h=sqrt(varC_abun_h),#SE of total abundance of condition
acd_h=mean(AdColDen,na.rm=T), # Mean of Site-Level all colonies in a Stratum
acd_abun_h=acd_h*nmtot*th, #strata-level abundnace of all colonies
prev=(C_abun_h/acd_abun_h)*100, # prevalence of condition at stratum level
SEprev=(SE_C_abun_h/acd_abun_h)*100,#SE of condition at stratum level
CVprev=(SEprev/prev)*100) #CV of prevalence
Strata_roll$M_hi=250 #define total possible transects in a site
Strata_roll=Strata_roll[,c("REGION","ISLAND","ANALYSIS_YEAR","DOMAIN_SCHEMA","ANALYSIS_SCHEMA","GROUP","REEF_ZONE","DB_RZ",
"M_hi","n_h","N_h","w_h","C_h","acd_h","varC_h","C_abun_h","varC_abun_h","acd_h","acd_abun_h",
"prev","SEprev")]
#remove strata that have only 1 site because you can't calculate variance
Strata_roll<-Strata_roll[Strata_roll$n_h>1,]
colnames(Strata_roll)[which(colnames(Strata_roll) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
return(Strata_roll)
}
#DOMAIN ROLL UP FUNCTION-This function calculates mean, var, SE and CV at the DOMAIN level. I've built in flexilbity to use either genus or taxoncode as well as other metrics (size class, morph)
# You can input any metric you would like (eg. adult density, mean % old dead,etc). Note that for any metric that does not involve density of colonies,
# Y._h (total colony abundance in stratum),varY._h (variance in total abundance), SE_Y._h and CV_Y._h are meaningless-DO NOT USE
Calc_Domain_Prevalence=function(site_data,grouping_field="S_ORDER",metric_field){
Strata_data=Calc_Strata_Prevalence(site_data,grouping_field,metric_field)
#Build in flexibility to look at genus or taxon level
Strata_data$GROUP<-Strata_data[,grouping_field]
DomainStr_NH=ddply(subset(Strata_data,GROUP=="SSSS"),.(REGION,ANALYSIS_YEAR,DOMAIN_SCHEMA),summarize,DomainSumN_h=sum(N_h,na.rm=TRUE)) #total possible sites in a domain
Strata_data<-left_join(Strata_data, DomainStr_NH)# add previous to strata data
Strata_data$w_h=Strata_data$N_h/Strata_data$DomainSumN_h
Domain_roll=ddply(Strata_data,.(REGION,ISLAND,ANALYSIS_YEAR,DOMAIN_SCHEMA,GROUP),summarize,
C_st=sum(w_h*C_h,na.rm=TRUE), #Domain weighted estimate (sum of Weighted strata density)
varC_st=sum(w_h^2*varC_h,na.rm=TRUE), #Domain weighted variance estimate
C_abun_st=sum(C_abun_h,na.rm=TRUE), #Domain total abundance of colonies with a given condition (sum of extrapolated strata abundance)
varC_abun_st=sum(varC_abun_h,na.rm=TRUE),#Domain variance total abundance of colonies with a given condition (sum of extrapolated strata varaiance abundance)
n=sum(n_h,na.rm=TRUE), #total sites surveyed in domain
Ntot=sum(N_h,na.rm=TRUE), #total possible sites in domain
SE_varC_st=sqrt(varC_st), #SE of domain metric estimate
CV_varC_st=SE_varC_st/C_st, #CV of domain metric estimate
SE_varC_abun_st=sqrt(varC_abun_st),#SE of domain abundance estimate
CV_varC_abun_st=SE_varC_abun_st/C_abun_st,#CV of domain abundnace estimate
acd_st=sum(w_h*acd_h,na.rm=TRUE), # sum of all colony densities across all strata in a given domain
acd_abun_st=sum(acd_abun_h,na.rm=TRUE), #domain abundnace of all colonies
prev=(C_abun_st/acd_abun_st)*100, # prevalence of condition at domain level
SEprev=(SE_varC_abun_st/acd_abun_st)*100,#SE of condition at domain level
CVprev=SEprev/prev) #CV of prevalence
Domain_roll=Domain_roll[,c("REGION","ISLAND","ANALYSIS_YEAR","DOMAIN_SCHEMA","GROUP",
"n","Ntot","prev","SEprev")]
colnames(Domain_roll)[which(colnames(Domain_roll) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
colnames(Domain_roll)[which(colnames(Domain_roll) == 'prev')] <- paste0("Mean","_",metric_field)
colnames(Domain_roll)[which(colnames(Domain_roll) == 'SEprev')] <- paste0("SE","_",metric_field)
return(Domain_roll)
}
####
#BSR-UNWEIGHTED FUNCTIONS####
####
Calc_Sitemetrics_BSR<-function(data, grouping_field){
a<-merge(data,survey_transect,by=c("SITE","SITEVISITID","TRANSECT"))
a$GROUP<-a[,grouping_field]
out<-ddply(a, .(OBS_YEAR,REGION_NAME,ISLAND,SITE,LATITUDE,LONGITUDE,REEF_ZONE,DEPTH_BIN,SITE_MAX_DEPTH,GROUP),
summarise,
ACD=mean(AdColDen,na.rm = TRUE),
JCD=mean(JuvColDen,na.rm = TRUE),
BLE=mean(BLEprev,na.rm = TRUE),
COTS=mean(COTSprev,na.rm=TRUE),
DZ=mean(TotDZprev,na.rm = TRUE),
AcuteDZ=mean(AcuteDZprev,na.rm = TRUE),
ChrDZ=mean(ChronicDZprev,na.rm = TRUE))
colnames(out)[which(colnames(out) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
return(out)
}
#
Calc_Islmetrics_BSR<-function(data, grouping_field="GENUS_CODE"){
data$GROUP<-data[,grouping_field]
out<-ddply(data, .(OBS_YEAR,REGION_NAME,ISLAND,GROUP),
summarise,
meanAdultColDen=mean(ACD,na.rm = TRUE),
meanJuvColDen=mean(JCD,na.rm = TRUE),
meanBLE=mean(BLE,na.rm = TRUE),
meanAcuteDZ=mean(AcuteDZ,na.rm = TRUE),
meanChrDZ=mean(ChrDZ,na.rm = TRUE),
meanDZ=mean(DZ,na.rm = TRUE),
meanCOTS=mean(COTS,na.rm = TRUE),
seCOTS=std.error(COTS,na.rm=TRUE),
seAdultColDen=std.error(ACD,na.rm=TRUE),
seJuvColDen=std.error(JCD,na.rm=TRUE),
seBLE=std.error(BLE,na.rm=TRUE),
seAcuteDZ=std.error(AcuteDZ,na.rm=TRUE),
seChrDZ=std.error(ChrDZ,na.rm=TRUE),
seDZ=std.error(DZ,na.rm=TRUE),
ntot=length(SITE))
colnames(out)[which(colnames(out) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
return(out)
}
Calc_IslDepthmetrics_BSR<-function(data, grouping_field="GENUS_CODE"){
data$GROUP<-data[,grouping_field]
out<-ddply(data, .(OBS_YEAR,REGION_NAME,ISLAND,DEPTH_BIN,GROUP),
summarise,
meanAdultColDen=mean(ACD,na.rm=TRUE),
meanJuvColDen=mean(JCD,na.rm=TRUE),
meanBLE=mean(BLE,na.rm=TRUE),
meanAcuteDZ=mean(AcuteDZ,na.rm=TRUE),
meanChrDZ=mean(ChrDZ,na.rm=TRUE),
meanDZ=mean(DZ,na.rm=TRUE),
meanCOTS=mean(COTS,na.rm = TRUE),
seCOTS=std.error(COTS,na.rm=TRUE),
seAdultColDen=std.error(ACD,na.rm=TRUE),
seJuvColDen=std.error(JCD,na.rm=TRUE),
seBLE=std.error(BLE,na.rm=TRUE),
seAcuteDZ=std.error(AcuteDZ,na.rm=TRUE),
seChrDZ=std.error(ChrDZ,na.rm=TRUE),
seDZ=std.error(DZ,na.rm=TRUE),
ntot=length(SITE))
colnames(out)[which(colnames(out) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
return(out)
}
Calc_IslReefZonemetrics_BSR<-function(data, grouping_field="GENUS_CODE"){
data$GROUP<-data[,grouping_field]
out<-ddply(data, .(OBS_YEAR,REGION,ISLAND,REEF_ZONE,GROUP),
summarise,
meanAdultColDen=mean(ACD,na.rm=TRUE),
meanJuvColDen=mean(JCD,na.rm=TRUE),
meanBLE=mean(BLE,na.rm=TRUE),
meanAcuteDZ=mean(AcuteDZ,na.rm=TRUE),
meanChrDZ=mean(ChrDZ,na.rm=TRUE),
meanDZ=mean(DZ,na.rm=TRUE),
meanCOTS=mean(COTS,na.rm = TRUE),
seCOTS=std.error(COTS,na.rm=TRUE),
seAdultColDen=std.error(ACD,na.rm=TRUE),
seJuvColDen=std.error(JCD,na.rm=TRUE),
seBLE=std.error(BLE,na.rm=TRUE),
seAcuteDZ=std.error(AcuteDZ,na.rm=TRUE),
seChrDZ=std.error(ChrDZ,na.rm=TRUE),
seDZ=std.error(DZ,na.rm=TRUE),
ntot=length(SITE))
colnames(out)[which(colnames(out) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
return(out)
}
####
#BSR-TEMPLATE FUNCTIONS####
####
zone_ord <- c("Forereef", "Backreef", "Lagoon")
reg_name <- function(x){ # this function returns the full name of an abbreviated region
if(x == "PRIAs"){y = "Pacific Remote Islands Areas"}
if(x == "MARIAN"){y = "Mariana Archipelago"}
if(x == "MHI"){y = "Main Hawaiian Islands"}
if(x == "NWHI"){y = "Northwestern Hawaiian Islands"}
if(x == "SAMOA"){y = "American Samoa"}
if(x == "NMAR"){y = "northern Mariana Archipelago"}
if(x == "SMAR"){y = "southern Mariana Archipelago"}
return(y)
}
island_order <- function(x){ # this function will return a list of the island names properly ordered for figures
PRIAorder <- c("Johnston", "Baker", "Howland", "Jarvis", "Kingman", "Palmyra")
NMARorder <- c("FDP", "Maug", "Asuncion", "Alamagan", "Pagan", "Agrihan", "Guguan", "Sarigan")
SMARorder <- c("Saipan", "Tinian", "Aguijan", "Rota", "Guam")
samoaorder <- c("Ofu & Olosega", "Rose", "Swains", "Tau", "Tutuila")
MHIorder <- c("Hawaii", "Maui", "Kahoolawe", "Lanai", "Molokai", "Oahu", "Kauai", "Niihau")
NWHIorder <- c("Necker", "French Frigate", "Gardner", "Maro", "Laysan", "Lisianski", "Pearl & Hermes", "Midway", "Kure")
MARIANorder <- c("FDP", "Maug", "Asuncion", "Alamagan", "Pagan", "Agrihan", "Guguan", "Sarigan", "Saipan", "Tinian", "Aguijan", "Rota", "Guam")
if(x == "Pacific Remote Island Areas" | x == "PRIAs"){y = PRIAorder}
if(x == "northern Mariana Islands" | x == "NMAR"){y = NMARorder}
if(x == "southern Mariana Islands" | x == "SMAR"){y = SMARorder}
if(x == "American Samoa" | x == "SAMOA"){y = samoaorder}
if(x == "Main Hawaiian Islands" | x == "MHI"){y = MHIorder}
if(x == "Northwestern Hawaiian Islands" | x == "NWHI"){y = NWHIorder}
if(x == "Mariana Archipelago" | x == "MARIAN"){y = NWHIorder}
return(y)
}
gen_name_fun <- function(gen){ # function to return genera name given abbreviation
gen <- as.character(gen)
lookup <-  read.csv("T:/Benthic/Data/SpGen_Reference/AllGenList.csv")
genera <- as.character(lookup[ which(lookup$Genus.code == gen),]$Genus)
return(genera)
}
spe_name_fun <- function(spe){ # function to return genera name given abbreviation
spe <- as.character(spe)
lookup <-  read.csv("T:/Benthic/Data/SpGen_Reference/AllSpList.csv")
spec <- as.character(lookup[ which(lookup$Species.code == spe),]$Species)
return(spec)
}
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg_DIVER(data = awd,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
jcd.gen<-Calc_ColDen_Seg_DIVER(jwd,"GENUS_CODE"); colnames(jcd.gen)[colnames(jcd.gen)=="ColCount"]<-"JuvColCount";colnames(jcd.gen)[colnames(jcd.gen)=="ColDen"]<-"JuvColDen"
jcd.gen<-subset(jcd.gen,select=-c(SEGAREA))
#c("COLONYLENGTH","RDEXTENT1", "RDEXTENT2", "RDEXTENT3", "OLDDEAD","SEVERITY_1","SEVERITY_2", "SEVERITY_3", "EXTENT_1", "EXTENT_2", "EXTENT_3")
cl.gen<-Calc_ColMetric_Seg_DIVER(data = awd,grouping_field = "GENUS_CODE",pool_fields = "COLONYLENGTH"); colnames(cl.gen)[colnames(cl.gen)=="Ave.y"]<-"Ave.cl" #Average % old dead
od.gen<-Calc_ColMetric_Seg_DIVER(data = awd,grouping_field = "GENUS_CODE",pool_fields = "OLDDEAD"); colnames(od.gen)[colnames(od.gen)=="Ave.y"]<-"Ave.od" #Average % old dead
rd.gen<-Calc_ColMetric_Seg_DIVER(data = awd,grouping_field = "GENUS_CODE",pool_fields = c("RDEXTENT1", "RDEXTENT2","RDEXTENT3")); colnames(rd.gen)[colnames(rd.gen)=="Ave.y"]<-"Ave.rd" #Average % recent dead
rdden.gen<-Calc_RDden_Seg_DIVER(data=awd,grouping_field ="GENUS_CODE") # Density of recent dead colonies by condition, you will need to subset which ever condition you want. The codes ending in "S" are the general categories
acutedz.gen<-subset(rdden.gen,select = c(METHOD,SITEVISITID,SITE,TRANSECT,SEGMENT,GENUS_CODE,DZGN_G));colnames(acutedz.gen)[colnames(acutedz.gen)=="DZGN_G"]<-"DZGN_G_den" #subset just acute diseased colonies
#Calc_RDden_Transect
rdden.gen<-Calc_RDden_Seg_DIVER(data=awd,grouping_field ="GENUS_CODE") # Density of recent dead colonies by condition, you will need to subset which ever condition you want. The codes ending in "S" are the general categories
View(Calc_RDden_Seg_DIVER)
scl<-subset(awd,Fragment==0 &S_ORDER=="Scleractinia")
scl$GENRD1<-paste(scl$GENRD1,"_G",sep="");scl$GENRD2<-paste(scl$GENRD2,"_G",sep="");scl$GENRD3<-paste(scl$GENRD3,"_G",sep="")
factor_cols <- c("GENRD1","GENRD2","GENRD3","RD1","RD2","RD3")
scl[factor_cols] <- lapply(scl[factor_cols], as.factor)
scl_l <- gather(data = scl, key = RDcat, value = RDtype, c(GENRD1,RD1,GENRD2,RD2,GENRD3,RD3), factor_key=TRUE)
rd<-dcast(scl_l, formula=METHOD+SITEVISITID + SITE+TRANSECT+SEGMENT+ANALYST+COLONYID ~ RDtype, value.var="RDtype",length,fill=0)
MDcol=c("METHOD","SITEVISITID","SITE","TRANSECT","SEGMENT","ANALYST","COLONYID")
DATAcol=setdiff(names(rd),MDcol)
rd.new=rd;  rd.new[,DATAcol][rd.new[,DATAcol]>1]=1
allrd3<-left_join(rd.new,survey_colony_f,by=MDcol)
allrd3<-left_join(rd.new,survey_colony,by=MDcol)
View(survey_colony)
SURVEY_COL<-c("METHOD","SITEVISITID", "OBS_YEAR", "REGION", "ISLAND","SEC_NAME", "SITE", "REEF_ZONE", "ANALYST",
"DEPTH_BIN", "LATITUDE", "LONGITUDE","MIN_DEPTH_M","MAX_DEPTH_M","TRANSECT","SEGMENT","COLONYID","GENUS_CODE","TAXONCODE","SPCODE","COLONYLENGTH")
survey_colony_DIVER<-unique(awd[,SURVEY_COL])
#Calc_RDden_Transect
rdden.gen<-Calc_RDden_Seg_DIVER(data=awd,grouping_field ="GENUS_CODE") # Density of recent dead colonies by condition, you will need to subset which ever condition you want. The codes ending in "S" are the general categories
#Calc_RDden_Transect
rdden.gen<-Calc_RDden_Seg_DIVER(data=awd,survey_colony_f=survey_colony_DIVER,grouping_field ="GENUS_CODE") # Density of recent dead colonies by condition, you will need to subset which ever condition you want. The codes ending in "S" are the general categories
acutedz.gen<-subset(rdden.gen,select = c(METHOD,SITEVISITID,SITE,TRANSECT,SEGMENT,GENUS_CODE,DZGN_G));colnames(acutedz.gen)[colnames(acutedz.gen)=="DZGN_G"]<-"DZGN_G_den" #subset just acute diseased colonies
#Calc_CONDden_Transect
condden.gen<-Calc_CONDden_Seg_DIVER(data=awd,grouping_field ="GENUS_CODE")# Density of condition colonies by condition, you will need to subset which ever condition you want
ble.gen<-subset(condden.gen,select = c(METHOD,SITEVISITID,SITE,TRANSECT,SEGMENT,GENUS_CODE,BLE));colnames(ble.gen)[colnames(ble.gen)=="BLE"]<-"BLE_den" #subset just bleached colonies
chronicdz.gen<-subset(condden.gen,select = c(METHOD,SITEVISITID,SITE,TRANSECT,SEGMENT,GENUS_CODE,CHRO));colnames(chronicdz.gen)[colnames(chronicdz.gen)=="CHRO"]<-"CHRO_den" #subset just chronic diseased colonies
#Join density and partial moratlity data together.You will need to replace the DUMMY field with the one you want
data.gen <- join_all(list(acd.gen,jcd.gen,cl.gen,od.gen,rd.gen,acutedz.gen,chronicdz.gen,ble.gen),
by=c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT","GENUS_CODE"), type='full')
View(data.gen)
data.gen$JuvColCount[is.na(data.gen$JuvColCount)]<-0;data.gen$JuvColDen[is.na(data.gen$JuvColDen)]<-0
data.gen$AdColCount[is.na(data.gen$AdColCount)]<-0;data.gen$AdColDen[is.na(data.gen$AdColDen)]<-0
#Calculate transect level prevalence for acute dz, chronic dz and bleaching
data.gen$DZGN_G_prev<-(data.gen$DZGN_G_den*data.gen$SEGAREA_ad)/data.gen$AdColCount*100
data.gen$BLE_prev<-(data.gen$BLE_den*data.gen$SEGAREA_ad)/data.gen$AdColCount*100
data.gen$CHRO_prev<-(data.gen$CHRO_den*data.gen$SEGAREA_ad)/data.gen$AdColCount*100
#Concatenate method, Site,Transect and segment
data.gen$MethodRep<-paste(data.gen$METHOD,data.gen$TRANSECT,sep="_")
data.gen$SS<-paste(data.gen$SITE,data.gen$SEGMENT,sep="_")
#Check that each site-segment remaining has 2 divers and 2 annotators
t1<-ddply(data.gen,.(SITE,SEGMENT),summarize,n=length(unique(MethodRep)));nrow(t1[t1$n==4,])
t1<-as.data.frame.matrix(table(data.gen$SS,data.gen$MethodRep));dim(t1)
t1<-t1%>%filter(t1$DIVER_2!=0);dim(t1)
t1<-t1%>%filter(t1$DIVER_1!=0);dim(t1)
t1<-t1%>%filter(t1$SfM_1!=0);dim(t1)
t1<-t1%>%filter(t1$SfM_2!=0);dim(t1)
#Make final dataframe to save
data.gen2<-left_join(data.gen,survey_segment)
if(nrow(data.gen)!=nrow(data.gen2)) {cat("WARNING: Dfs didn't merge properly")}
#Save file for larger comparative analysis
write.csv(data.gen2,file="T:/Benthic/Data/SfM/Summarized Data/HARAMP_repeats_GENUS_Summarized Data.csv",row.names = F)
write.csv(data.gen2,file="T:/Benthic/Data/SfM/Summarized Data/HARAMP_repeats_GENUS_ANALYST_Summarized Data.csv",row.names = F)
data.gen<-read.csv("T:/Benthic/Data/SfM/Summarized Data/HARAMP_repeats_GENUS_ANALYST_Summarized Data.csv") #comparison utilizing orginal observer names
rm(list=ls())
#source("C:/Users/Courtney.S.Couch/Documents/GitHub/Benthic-Scripts/Functions/SfMvDiver Plotting Functions.R")
source("C:/Users/Corinne.Amir/Documents/GitHub/Benthic-Scripts/Functions/SfMvDiver Plotting Functions.R")
data.gen<-read.csv("T:/Benthic/Data/SfM/Summarized Data/HARAMP_repeats_GENUS_ANALYST_Summarized Data.csv") #comparison utilizing orginal observer names
View(data.gen)
