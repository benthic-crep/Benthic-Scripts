#Calculate SEGMENT area surveyed and colony density***
uTA=unique(data[,c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT","SEGAREA")])
out<-join(uTA,ca3, by=c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT"))
out$ColDen<-out$ColCount/out$SEGAREA
colnames(out)[which(colnames(out) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
#if(nrow(out)!=nrow(ca3)) {cat("WARNING:Segment-level data not merging properly")}   # should be 0
return(out)
}
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = awd,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
a<-ddply(awd, .(METHOD,SITE,SITEVISITID,TRANSECT, SEGMENT,S_ORDER,GROUP,Fragment,ANALYST),
summarise,
ColCount=length(COLONYID))
## This function calculates colony density at the segment scale by first calculating the total survey area (using Calc_SurveyArea_By_Seg) then calculating colony density
Calc_ColDen_Seg<-function(data, grouping_field="GENUS_CODE"){
data$GROUP<-data[,grouping_field] #assign a grouping field for taxa
#Calculate # of colonies for each variable. You need to have S_ORDER and Fragment here so you can incorporate zeros properly later in the code
a<-ddply(data, .(METHOD,SITE,SITEVISITID,TRANSECT, SEGMENT,S_ORDER,GROUP,Fragment),
summarise,
ColCount=length(COLONYID)) #change to count
#Convert from long to wide and insert 0s for taxa that weren't found at each site.
ca0=spread(a,key=GROUP,value=ColCount,fill=0) #Keepin' it TIDYR
data.cols<-names(ca0[8:dim(ca0)[2]]) #define your data coloumns- note you need to index by column number not by names-you may have situations where there are no AAAA
field.cols<-c("METHOD","SITE", "SITEVISITID", "TRANSECT","SEGMENT","Fragment") #define field columns
### Drop all fragments, but don't drop a fragment-only transect... ###
#change colony counts for fragments to 0 so that we account for the transects that only had fragments
ca0[which(ca0$Fragment <0), data.cols]<-0
#At this point you will have multiple rows for each site/transect so sum data by site and transect. This will help you properly insert 0s
field.cols<-c("METHOD","SITE", "SITEVISITID", "TRANSECT","SEGMENT")
ca1<-aggregate(ca0[,data.cols], by=ca0[,field.cols], sum)
rm(list='ca0')
#Create a list of scleractinian taxa that are in the dataframe as columns then sum across just those taxa to get total scl
b<-subset(data,S_ORDER=="Scleractinia");taxalist<-as.character(unique(b$GROUP))
ca1$SSSS<-rowSums(ca1[,taxalist,drop=FALSE]) #calculate total colony density
ca2 <- gather(ca1, GROUP, ColCount, names(ca1[6:dim(ca1)[2]]), factor_key=TRUE) #convert wide to long format
rm(list='ca1')
#Remove everything that isn't a scleractinian
taxalist2<-c(taxalist,"SSSS")
ca3<-ca2[ca2$GROUP %in% taxalist2,]
rm(list='ca2')
#Calculate SEGMENT area surveyed and colony density***
uTA=unique(data[,c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT","SEGAREA")])
out<-join(uTA,ca3, by=c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT"))
out$ColDen<-out$ColCount/out$SEGAREA
colnames(out)[which(colnames(out) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
#if(nrow(out)!=nrow(ca3)) {cat("WARNING:Segment-level data not merging properly")}   # should be 0
return(out)
}
## This function calculates mean colony length, % recent dead, % old dead, condition severity or condition extent to the segment level
## NOTE: can run both adult & juvenile data with this function for COLONYLENGTH
#may be worth changing to "Calc_ColMetric_Seg<-function(data, grouping_field, pool_fields)" and finding a workaround for the dcast warning before it turns into an error
Calc_ColMetric_Seg<-function(data, grouping_field="GENUS_CODE", pool_fields=c("COLONYLENGTH","RDEXTENT1", "RDEXTENT2","OLDDEAD","SEVERITY","EXTENT")) {
scl<-subset(data,Fragment==0&S_ORDER=="Scleractinia") #excludes fragments and anything that isn't a hard coral
scl$GROUP<-scl[,grouping_field]
scl$y <- rowSums(scl[,pool_fields,drop=FALSE], na.rm=TRUE) #this will allow you to add the 2 recent dead columns if you are looking at this metric
rd<-ddply(scl, .(METHOD,SITE,SITEVISITID,TRANSECT,SEGMENT,GROUP),
summarise,
Ave.y=mean(y, na.rm=TRUE))
rdtot<-ddply(scl, .(METHOD,SITE,SITEVISITID,TRANSECT,SEGMENT),
summarise,
Ave.y=mean(y, na.rm=TRUE))
rdtot$GROUP<-"SSSS"; rdtot <- rdtot[c(1,2,3,4,5,7,6)]
rd_wide<-dcast(rd, formula=METHOD+ SITE + SITEVISITID +TRANSECT+SEGMENT~ GROUP, value.var="Ave.y",fill=0)
rd_long <- gather(rd_wide, GROUP, Ave.y, names(rd_wide[6:dim(rd_wide)[2]]), factor_key=TRUE) #convert wide to long format
rd_long<-rbind(rd,rdtot)
colnames(rd_long)[which(colnames(rd_long) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
return(rd_long)
}
#Updated 12/27/19
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = awd,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
View(acd.gen)
## This function calculates colony density at the segment scale by first calculating the total survey area (using Calc_SurveyArea_By_Seg) then calculating colony density
Calc_ColDen_Seg<-function(data, grouping_field="GENUS_CODE"){
data$GROUP<-data[,grouping_field] #assign a grouping field for taxa
#Calculate # of colonies for each variable. You need to have S_ORDER and Fragment here so you can incorporate zeros properly later in the code
a<-ddply(data, .(METHOD,SITE,SITEVISITID,TRANSECT, SEGMENT,S_ORDER,GROUP,Fragment),
summarise,
ColCount=length(COLONYID)) #change to count
#Convert from long to wide and insert 0s for taxa that weren't found at each site.
ca0=spread(a,key=GROUP,value=ColCount,fill=0) #Keepin' it TIDYR
data.cols<-names(ca0[8:dim(ca0)[2]]) #define your data coloumns- note you need to index by column number not by names-you may have situations where there are no AAAA
field.cols<-c("METHOD","SITE", "SITEVISITID", "TRANSECT","SEGMENT","Fragment") #define field columns
### Drop all fragments, but don't drop a fragment-only transect... ###
#change colony counts for fragments to 0 so that we account for the transects that only had fragments
ca0[which(ca0$Fragment <0), data.cols]<-0
#At this point you will have multiple rows for each site/transect so sum data by site and transect. This will help you properly insert 0s
field.cols<-c("METHOD","SITE", "SITEVISITID", "TRANSECT","SEGMENT","ANALYST")
ca1<-aggregate(ca0[,data.cols], by=ca0[,field.cols], sum)
rm(list='ca0')
#Create a list of scleractinian taxa that are in the dataframe as columns then sum across just those taxa to get total scl
b<-subset(data,S_ORDER=="Scleractinia");taxalist<-as.character(unique(b$GROUP))
ca1$SSSS<-rowSums(ca1[,taxalist,drop=FALSE]) #calculate total colony density
ca2 <- gather(ca1, GROUP, ColCount, names(ca1[6:dim(ca1)[2]]), factor_key=TRUE) #convert wide to long format
rm(list='ca1')
#Remove everything that isn't a scleractinian
taxalist2<-c(taxalist,"SSSS")
ca3<-ca2[ca2$GROUP %in% taxalist2,]
rm(list='ca2')
#Calculate SEGMENT area surveyed and colony density***
uTA=unique(data[,c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT","SEGAREA")])
out<-join(uTA,ca3, by=c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT"))
out$ColDen<-out$ColCount/out$SEGAREA
colnames(out)[which(colnames(out) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
#if(nrow(out)!=nrow(ca3)) {cat("WARNING:Segment-level data not merging properly")}   # should be 0
return(out)
}
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = awd,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
#updated 2/4/20
## This function calculates colony density at the segment scale by first calculating the total survey area (using Calc_SurveyArea_By_Seg) then calculating colony density
Calc_ColDen_Seg<-function(data, grouping_field="GENUS_CODE"){
data$GROUP<-data[,grouping_field] #assign a grouping field for taxa
#Calculate # of colonies for each variable. You need to have S_ORDER and Fragment here so you can incorporate zeros properly later in the code
a<-ddply(data, .(METHOD,SITE,SITEVISITID,TRANSECT, SEGMENT,S_ORDER,GROUP,Fragment),
summarise,
ColCount=length(COLONYID)) #change to count
#Convert from long to wide and insert 0s for taxa that weren't found at each site.
ca0=spread(a,key=GROUP,value=ColCount,fill=0) #Keepin' it TIDYR
data.cols<-names(ca0[8:dim(ca0)[2]]) #define your data coloumns- note you need to index by column number not by names-you may have situations where there are no AAAA
field.cols<-c("METHOD","SITE", "SITEVISITID", "TRANSECT","SEGMENT","Fragment", "ANALYST") #define field columns
### Drop all fragments, but don't drop a fragment-only transect... ###
#change colony counts for fragments to 0 so that we account for the transects that only had fragments
ca0[which(ca0$Fragment <0), data.cols]<-0
#At this point you will have multiple rows for each site/transect so sum data by site and transect. This will help you properly insert 0s
field.cols<-c("METHOD","SITE", "SITEVISITID", "TRANSECT","SEGMENT","ANALYST")
ca1<-aggregate(ca0[,data.cols], by=ca0[,field.cols], sum)
rm(list='ca0')
#Create a list of scleractinian taxa that are in the dataframe as columns then sum across just those taxa to get total scl
b<-subset(data,S_ORDER=="Scleractinia");taxalist<-as.character(unique(b$GROUP))
ca1$SSSS<-rowSums(ca1[,taxalist,drop=FALSE]) #calculate total colony density
ca2 <- gather(ca1, GROUP, ColCount, names(ca1[6:dim(ca1)[2]]), factor_key=TRUE) #convert wide to long format
rm(list='ca1')
#Remove everything that isn't a scleractinian
taxalist2<-c(taxalist,"SSSS")
ca3<-ca2[ca2$GROUP %in% taxalist2,]
rm(list='ca2')
#Calculate SEGMENT area surveyed and colony density***
uTA=unique(data[,c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT","SEGAREA", "ANALYST")])
out<-join(uTA,ca3, by=c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT", "ANALYST"))
out$ColDen<-out$ColCount/out$SEGAREA
colnames(out)[which(colnames(out) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
#if(nrow(out)!=nrow(ca3)) {cat("WARNING:Segment-level data not merging properly")}   # should be 0
return(out)
}
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = awd,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
## This function calculates colony density at the segment scale by first calculating the total survey area (using Calc_SurveyArea_By_Seg) then calculating colony density
Calc_ColDen_Seg<-function(data, grouping_field="GENUS_CODE"){
data$GROUP<-data[,grouping_field] #assign a grouping field for taxa
#Calculate # of colonies for each variable. You need to have S_ORDER and Fragment here so you can incorporate zeros properly later in the code
a<-ddply(data, .(METHOD,SITE,SITEVISITID,TRANSECT,ANALYST,SEGMENT,S_ORDER,GROUP,Fragment),
summarise,
ColCount=length(COLONYID)) #change to count
#Convert from long to wide and insert 0s for taxa that weren't found at each site.
ca0=spread(a,key=GROUP,value=ColCount,fill=0) #Keepin' it TIDYR
data.cols<-names(ca0[8:dim(ca0)[2]]) #define your data coloumns- note you need to index by column number not by names-you may have situations where there are no AAAA
field.cols<-c("METHOD","SITE", "SITEVISITID", "TRANSECT","SEGMENT","Fragment", "ANALYST") #define field columns
### Drop all fragments, but don't drop a fragment-only transect... ###
#change colony counts for fragments to 0 so that we account for the transects that only had fragments
ca0[which(ca0$Fragment <0), data.cols]<-0
#At this point you will have multiple rows for each site/transect so sum data by site and transect. This will help you properly insert 0s
field.cols<-c("METHOD","SITE", "SITEVISITID", "TRANSECT","SEGMENT","ANALYST")
ca1<-aggregate(ca0[,data.cols], by=ca0[,field.cols], sum)
rm(list='ca0')
#Create a list of scleractinian taxa that are in the dataframe as columns then sum across just those taxa to get total scl
b<-subset(data,S_ORDER=="Scleractinia");taxalist<-as.character(unique(b$GROUP))
ca1$SSSS<-rowSums(ca1[,taxalist,drop=FALSE]) #calculate total colony density
ca2 <- gather(ca1, GROUP, ColCount, names(ca1[6:dim(ca1)[2]]), factor_key=TRUE) #convert wide to long format
rm(list='ca1')
#Remove everything that isn't a scleractinian
taxalist2<-c(taxalist,"SSSS")
ca3<-ca2[ca2$GROUP %in% taxalist2,]
rm(list='ca2')
#Calculate SEGMENT area surveyed and colony density***
uTA=unique(data[,c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT","SEGAREA", "ANALYST")])
out<-join(uTA,ca3, by=c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT", "ANALYST"))
out$ColDen<-out$ColCount/out$SEGAREA
colnames(out)[which(colnames(out) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
#if(nrow(out)!=nrow(ca3)) {cat("WARNING:Segment-level data not merging properly")}   # should be 0
return(out)
}
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = awd,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
a<-ddply(awd, .(METHOD,SITE,SITEVISITID,TRANSECT,ANALYST,SEGMENT,S_ORDER,GROUP,Fragment),
summarise,
ColCount=length(COLONYID))
#updated 2/4/20
## This function calculates colony density at the segment scale by first calculating the total survey area (using Calc_SurveyArea_By_Seg) then calculating colony density
Calc_ColDen_Seg<-function(data, grouping_field="GENUS_CODE"){
data$GROUP<-data[,grouping_field] #assign a grouping field for taxa
#Calculate # of colonies for each variable. You need to have S_ORDER and Fragment here so you can incorporate zeros properly later in the code
a<-ddply(data, .(METHOD,SITE,SITEVISITID,TRANSECT,ANALYST,SEGMENT,S_ORDER,GROUP,Fragment),
summarise,
ColCount=length(COLONYID)) #change to count
#Convert from long to wide and insert 0s for taxa that weren't found at each site.
ca0=spread(a,key=GROUP,value=ColCount,fill=0) #Keepin' it TIDYR
data.cols<-names(ca0[8:dim(ca0)[2]]) #define your data coloumns- note you need to index by column number not by names-you may have situations where there are no AAAA
field.cols<-c("METHOD","SITE", "SITEVISITID", "TRANSECT","ANALYST","SEGMENT","Fragment") #define field columns
### Drop all fragments, but don't drop a fragment-only transect... ###
#change colony counts for fragments to 0 so that we account for the transects that only had fragments
ca0[which(ca0$Fragment <0), data.cols]<-0
#At this point you will have multiple rows for each site/transect so sum data by site and transect. This will help you properly insert 0s
field.cols<-c("METHOD","SITE", "SITEVISITID", "TRANSECT","ANALYST","SEGMENT")
ca1<-aggregate(ca0[,data.cols], by=ca0[,field.cols], sum)
rm(list='ca0')
#Create a list of scleractinian taxa that are in the dataframe as columns then sum across just those taxa to get total scl
b<-subset(data,S_ORDER=="Scleractinia");taxalist<-as.character(unique(b$GROUP))
ca1$SSSS<-rowSums(ca1[,taxalist,drop=FALSE]) #calculate total colony density
ca2 <- gather(ca1, GROUP, ColCount, names(ca1[6:dim(ca1)[2]]), factor_key=TRUE) #convert wide to long format
rm(list='ca1')
#Remove everything that isn't a scleractinian
taxalist2<-c(taxalist,"SSSS")
ca3<-ca2[ca2$GROUP %in% taxalist2,]
rm(list='ca2')
#Calculate SEGMENT area surveyed and colony density***
uTA=unique(data[,c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT","SEGAREA", "ANALYST")])
out<-join(uTA,ca3, by=c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT"))
out$ColDen<-out$ColCount/out$SEGAREA
colnames(out)[which(colnames(out) == 'GROUP')] <- grouping_field #change group to whatever your grouping field is.
#if(nrow(out)!=nrow(ca3)) {cat("WARNING:Segment-level data not merging properly")}   # should be 0
return(out)
}
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = awd,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
uTA=unique(awd[,c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT","SEGAREA", "ANALYST")])
View(uTA)
#LOAD LIBRARY FUNCTIONS ...
# source("C:/Users/Courtney.S.Couch/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_newApp_vTAOfork.R")
# source("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/lib/core_functions.R")
# source("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/lib/GIS_functions.R")
source("C:/Users/Corinne.Amir/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_newApp_vTAOfork.R")
source("C:/Users/Corinne.Amir/Documents/GitHub/fish-paste/lib/core_functions.R")
source("C:/Users/Corinne.Amir/Documents/GitHub/fish-paste/lib/GIS_functions.R")
## DIVER-ADULT: Load benthic data
# setwd("C:/Users/Courtney.S.Couch/Documents/Courtney's Files/R Files/ESD/Benthic REA")
load("T:/Benthic/Data/REA Coral Demography & Cover/Raw from Oracle/ALL_REA_ADULTCORAL_RAW_2013-2019.rdata") #from oracle
x<-df
x$SITE<-SiteNumLeadingZeros(x$SITE) # Change site number such as MAR-22 to MAR-0022
#Convert date formats
class(x$DATE_)
x$DATE_ <- as.Date(x$DATE_, format = "%Y-%m-%d")
### Use these functions to look at data
head(x)
tail(x)
sapply(x, unique)
table(x$REGION, x$OBS_YEAR) #review years and regions in dataframe
#Convert Segment number from old to new numbering system
#x$SEGMENT<-ConvertSegNumber(x) #DONT USE...ITS ALREADY BEEN CORRECTED WITHIN ORACLE
head(table(x$SITE,x$SEGMENT)) #Double check that segment numbers are correct
#Create vector of column names to include then exclude unwanted columns from dataframe
DATA_COLS<-c("MISSIONID","REGION","REGION_NAME","ISLAND","ISLANDCODE","SITE","LATITUDE",	"LONGITUDE","REEF_ZONE","DEPTH_BIN","OBS_YEAR",
"DATE_","NO_SURVEY_YN","EXCLUDE_FLAG","SITEVISITID","HABITAT_CODE","DIVER","TRANSECTNUM","SEGMENT","SEGWIDTH","SEGLENGTH","FRAGMENT_YN",
"COLONYID","TAXONCODE","COLONYLENGTH","OLDDEAD",
"RECENTDEAD_1","RECENT_GENERAL_CAUSE_CODE_1","RECENT_SPECIFIC_CAUSE_CODE_1",
"RECENTDEAD_2",	"RECENT_GENERAL_CAUSE_CODE_2","RECENT_SPECIFIC_CAUSE_CODE_2",
"RECENT_GENERAL_CAUSE_CODE_3","RECENT_SPECIFIC_CAUSE_CODE_3","RECENTDEAD_3","COND",
"CONDITION_2","CONDITION_3","EXTENT_1","EXTENT_2","EXTENT_3","SEVERITY_1","SEVERITY_2","SEVERITY_3",
"GENUS_CODE","S_ORDER","TAXONNAME","SITE_MIN_DEPTH","SITE_MAX_DEPTH")
x<-subset(x,REGION=="MHI" & OBS_YEAR =="2019") #subset just MHI 2019 data
#remove extraneous columns
head(x[,DATA_COLS])
x<-x[,DATA_COLS]
sort(colnames(x))
#Double check level and class of variables to make sure there aren't any errors
sapply(x,levels)
sapply(x,class)##Change column names to make code easier to code
#Logical NAs within RECENT_GENERAL/SPECIFIC_CAUSE_CODEs, conditions, and extents, but only SEVERITY_4 = logical class
#DIVER/ADULT: Column Names Changes... -------------------------------------------------
colnames(x)[colnames(x)=="TAXONCODE"]<-"SPCODE" #Change column name- we will eventually change this column back to "taxoncode" after we modify the spcode names to match the taxalist we all feel comfortable identifying
colnames(x)[colnames(x)=="TRANSECTNUM"]<-"TRANSECT" #Change column name
colnames(x)[colnames(x)=="RECENTDEAD_1"]<-"RDEXTENT1" #Change column name
colnames(x)[colnames(x)=="RECENT_GENERAL_CAUSE_CODE_1"]<-"GENRD1" #Change column name
colnames(x)[colnames(x)=="RECENT_SPECIFIC_CAUSE_CODE_1"]<-"RD1" #Change column name
colnames(x)[colnames(x)=="RECENTDEAD_2"]<-"RDEXTENT2" #Change column name
colnames(x)[colnames(x)=="RECENTDEAD_3"]<-"RDEXTENT3" #Change column name
colnames(x)[colnames(x)=="RECENT_GENERAL_CAUSE_CODE_2"]<-"GENRD2" #Change column name
colnames(x)[colnames(x)=="RECENT_SPECIFIC_CAUSE_CODE_2"]<-"RD2" #Change column name
colnames(x)[colnames(x)=="RECENT_GENERAL_CAUSE_CODE_3"]<-"GENRD3" #Change column name
colnames(x)[colnames(x)=="RECENT_SPECIFIC_CAUSE_CODE_3"]<-"RD3" #Change column name
colnames(x)[colnames(x)=="FRAGMENT_YN"]<-"Fragment" #Change column name
colnames(x)[colnames(x)=="COND"]<-"CONDITION_1" #Change column name
#Add column for method type
x$METHOD<-"DIVER"
if(DEBUG){head(x)}
#DIVER/ADULT: Merge Diver/Adult data and SURVEY MASTER -------------------------------------
#SURVEY MASTER was created by Ivor and Courtney by extracting sites directly from the Site Visit table from Oracle. It should be the complete list of sites surveyed since 2000
#survey_master<-read.csv("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/data/SURVEY MASTER.csv")
setwd("C:/Users/Corinne.Amir/Documents/GitHub/Benthic-Scripts/SfM")
survey_master <- read.csv("SURVEY MASTER.csv")
#Check that OBS_YEAR, SITEVISITID, and SITE are all the same in both x and survey master
OYerror=which(x$OBS_YEAR!=survey_master$OBS_YEAR[match(x$SITEVISITID,survey_master$SITEVISITID)])
SIerror=which(as.vector(x$SITE)!=survey_master$SITE[match(x$SITEVISITID,survey_master$SITEVISITID)])
SIOYerrors=unique(c(OYerror,SIerror))
if(length(SIOYerrors)>0){print(paste0("Warning: Raw Data disagree with Survey Master for sitevisitids: ",x$SITEVISITID[SIOYerrors]))}
#add SITE MASTER information to x
length(unique(x$SITEVISITID)) #check the number of sites in demographic data
#join 'em
x<- inner_join(x, survey_master[,c("OBS_YEAR","SITEVISITID","SITE","SEC_NAME","ANALYSIS_YEAR","bANALYSIS_SCHEME","MIN_DEPTH_M","MAX_DEPTH_M")], by=c("OBS_YEAR","SITEVISITID","SITE"))
#Ensure that all rows in X have properly assigned SEC_NAME...
####CHECK THAT all SEC_NAME are present in the survey_master file
test<-x[is.na(x$SEC_NAME), c("MISSIONID","REGION", "SITE","OBS_YEAR"),]
test<-droplevels(test);table(test$SITE,test$MISSIONID) #create a table of missing sites by missionid
if(dim(test)[1]>0) {cat("Warning: sites with MISSING SECTORS present")}   # should be 0
#Create a list of missing sites that can be imported into the SITE MASTER file if needed
test<-x[is.na(x$SEC_NAME),]
miss.sites<-ddply(test,.(OBS_YEAR,SITEVISITID,SITE,MISSIONID,REGION,REGION_NAME,ISLAND,LATITUDE,LONGITUDE,
REEF_ZONE,DEPTH_BIN,DATE_,EXCLUDE_FLAG,HABITAT_CODE),
summarize,temp=median(SITEVISITID),SITE_MAX_DEPTH=median(SITE_MAX_DEPTH),SITE_MIN_DEPTH=median(SITE_MIN_DEPTH))
#Should be a 0 row data.frame
head(miss.sites,20)
#DIVER/ADULT: CLEAN UP ----------------------------------------------------------------
#Generate General RD cause code
gencodes<-read.csv("T:/Benthic/Data/Lookup Tables/GeneralRDcode_lookup.csv")
head(x)
levels(x$RD1)
#Remove exisiting GENRD columns until Michael can fix database
x<-subset(x,select=-c(GENRD1,GENRD2,GENRD3))
x<- droplevels(x)
x<-CreateGenRDCode(x,"RD1","GENRD1",gencodes) #Creates an additional column in x (called GENRD#) that has the generalized code associated with the given RD#--ok
x<-CreateGenRDCode(x,"RD2","GENRD2",gencodes)
x<-CreateGenRDCode(x,"RD3","GENRD3",gencodes)
x <- droplevels(x)
head(x)
##Remove sites that were only surveyed for photoquads but not demographics
#Note-photoquad only sites are not included in data prior to 2018
#Test whether there are missing values in the NO_SURVEY_YN column. The value should be 0 or -1
x.na<-x[is.na(x$NO_SURVEY_YN)&x$OBS_YEAR>2013,]
x.na
# test<-ddply(x.na,.(SITE),
#             summarize,
#             SEG=length(unique(SEGMENT)))
# test
x$NO_SURVEY_YN[is.na(x$NO_SURVEY_YN)]<-0 #Change NAs (blank cells) to 0
##Acutally do the removal of transects that were only surveyed for photoquads but not demographics
x<-subset(x,NO_SURVEY_YN==0)
#TEMPORARY FIX-SPEAK WITH DM TO CORRECT IN ORACLE
x<-subset(x,SEGLENGTH!="NA") #Remove segments that were not surveyed for coral demography (no SEGLENGTH=0 in db)
#Actually remove special missions.
x<-subset(x,EXCLUDE_FLAG==0);
# this dataframe should be empty
head(subset(x,EXCLUDE_FLAG==-1))
head(x)
#Change NAs in RecentDead extent to 0
head(subset(x,S_ORDER=="Scleractinia" & is.na(x$RDEXTENT1))) #identify columns that have NAs
x$RDEXTENT1<-ifelse(x$S_ORDER=="Scleractinia"& is.na(x$RDEXTENT1),0,x$RDEXTENT1)
head(subset(x,S_ORDER=="Scleractinia" & is.na(x$RDEXTENT2))) #identify columns that have NAs
x$RDEXTENT2<-ifelse(x$S_ORDER=="Scleractinia"& is.na(x$RDEXTENT2),0,x$RDEXTENT2)
head(subset(x,S_ORDER=="Scleractinia" & is.na(x$RDEXTENT3))) #identify columns that have NAs
x$RDEXTENT3<-ifelse(x$S_ORDER=="Scleractinia"& is.na(x$RDEXTENT3),0,x$RDEXTENT3)
#DIVER/ADULT: Assign TAXONCODE --------------------------------------------------------
#read in list of taxa that we feel comfortable identifying to species or genus level. Note, taxa lists vary by year and region. This will need to be updated through time.
taxa<-read.csv("T:/Benthic/Data/Lookup Tables/2013-19_Taxa_MASTER.csv")
#Convert SPCODE in raw colony data to TAXONCODE -generates a look up table
#x$TAXONCODE<-Convert_to_Taxoncode_tom(data = x,taxamaster = taxa)#not working need to ask tom
taxa$OBS_YEAR<-as.numeric(as.character(taxa$OBS_YEAR))
x$SPCODE<-ifelse(x$NO_COLONY_==-1,"AAAA",as.character(x$SPCODE))
x <-Convert_to_Taxoncode(x,taxa)
#DIVER/ADULT: Assign TAXONCODE --------------------------------------------------------
#read in list of taxa that we feel comfortable identifying to species or genus level. Note, taxa lists vary by year and region. This will need to be updated through time.
taxa<-read.csv("T:/Benthic/Data/Lookup Tables/2013-19_Taxa_MASTER.csv")
#Convert SPCODE in raw colony data to TAXONCODE -generates a look up table
#x$TAXONCODE<-Convert_to_Taxoncode_tom(data = x,taxamaster = taxa)#not working need to ask tom
taxa$OBS_YEAR<-as.numeric(as.character(taxa$OBS_YEAR))
#Convert SPCODE in raw colony data to TAXONCODE -generates a look up table
#x$TAXONCODE<-Convert_to_Taxoncode_tom(data = x,taxamaster = taxa)#not working need to ask tom
taxa$OBS_YEAR<-as.numeric(as.character(taxa$OBS_YEAR))
x$SPCODE<-ifelse(x$NO_COLONY_==-1,"AAAA",as.character(x$SPCODE))
#DIVER/ADULT: CLEAN ANALYSIS READY DATA----------------------------------------
# This script will clean the raw benthic REA data using method E that comes directly from the new data base application.
rm(list=ls())
#Set Run Flags
DEBUG=TRUE
#LOAD LIBRARY FUNCTIONS ...
# source("C:/Users/Courtney.S.Couch/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_newApp_vTAOfork.R")
# source("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/lib/core_functions.R")
# source("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/lib/GIS_functions.R")
source("C:/Users/Corinne.Amir/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_newApp_vTAOfork.R")
source("C:/Users/Corinne.Amir/Documents/GitHub/fish-paste/lib/core_functions.R")
source("C:/Users/Corinne.Amir/Documents/GitHub/fish-paste/lib/GIS_functions.R")
## DIVER-ADULT: Load benthic data
# setwd("C:/Users/Courtney.S.Couch/Documents/Courtney's Files/R Files/ESD/Benthic REA")
load("T:/Benthic/Data/REA Coral Demography & Cover/Raw from Oracle/ALL_REA_ADULTCORAL_RAW_2013-2019.rdata") #from oracle
x<-df
x$SITE<-SiteNumLeadingZeros(x$SITE) # Change site number such as MAR-22 to MAR-0022
#Convert date formats
class(x$DATE_)
x$DATE_ <- as.Date(x$DATE_, format = "%Y-%m-%d")
### Use these functions to look at data
head(x)
tail(x)
sapply(x, unique)
table(x$REGION, x$OBS_YEAR) #review years and regions in dataframe
#Convert Segment number from old to new numbering system
#x$SEGMENT<-ConvertSegNumber(x) #DONT USE...ITS ALREADY BEEN CORRECTED WITHIN ORACLE
head(table(x$SITE,x$SEGMENT)) #Double check that segment numbers are correct
#Create vector of column names to include then exclude unwanted columns from dataframe
DATA_COLS<-c("MISSIONID","REGION","REGION_NAME","ISLAND","ISLANDCODE","SITE","LATITUDE",	"LONGITUDE","REEF_ZONE","DEPTH_BIN","OBS_YEAR",
"DATE_","NO_SURVEY_YN","EXCLUDE_FLAG","SITEVISITID","HABITAT_CODE","DIVER","TRANSECTNUM","SEGMENT","SEGWIDTH","SEGLENGTH","FRAGMENT_YN",
"COLONYID","TAXONCODE","COLONYLENGTH","OLDDEAD",
"RECENTDEAD_1","RECENT_GENERAL_CAUSE_CODE_1","RECENT_SPECIFIC_CAUSE_CODE_1",
"RECENTDEAD_2",	"RECENT_GENERAL_CAUSE_CODE_2","RECENT_SPECIFIC_CAUSE_CODE_2",
"RECENT_GENERAL_CAUSE_CODE_3","RECENT_SPECIFIC_CAUSE_CODE_3","RECENTDEAD_3","COND",
"CONDITION_2","CONDITION_3","EXTENT_1","EXTENT_2","EXTENT_3","SEVERITY_1","SEVERITY_2","SEVERITY_3",
"GENUS_CODE","S_ORDER","TAXONNAME","SITE_MIN_DEPTH","SITE_MAX_DEPTH")
x<-subset(x,REGION=="MHI" & OBS_YEAR =="2019") #subset just MHI 2019 data
#remove extraneous columns
head(x[,DATA_COLS])
x<-x[,DATA_COLS]
sort(colnames(x))
#Double check level and class of variables to make sure there aren't any errors
sapply(x,levels)
sapply(x,class)##Change column names to make code easier to code
#Logical NAs within RECENT_GENERAL/SPECIFIC_CAUSE_CODEs, conditions, and extents, but only SEVERITY_4 = logical class
#DIVER/ADULT: Column Names Changes... -------------------------------------------------
colnames(x)[colnames(x)=="TAXONCODE"]<-"SPCODE" #Change column name- we will eventually change this column back to "taxoncode" after we modify the spcode names to match the taxalist we all feel comfortable identifying
colnames(x)[colnames(x)=="TRANSECTNUM"]<-"TRANSECT" #Change column name
colnames(x)[colnames(x)=="RECENTDEAD_1"]<-"RDEXTENT1" #Change column name
colnames(x)[colnames(x)=="RECENT_GENERAL_CAUSE_CODE_1"]<-"GENRD1" #Change column name
colnames(x)[colnames(x)=="RECENT_SPECIFIC_CAUSE_CODE_1"]<-"RD1" #Change column name
colnames(x)[colnames(x)=="RECENTDEAD_2"]<-"RDEXTENT2" #Change column name
colnames(x)[colnames(x)=="RECENTDEAD_3"]<-"RDEXTENT3" #Change column name
colnames(x)[colnames(x)=="RECENT_GENERAL_CAUSE_CODE_2"]<-"GENRD2" #Change column name
colnames(x)[colnames(x)=="RECENT_SPECIFIC_CAUSE_CODE_2"]<-"RD2" #Change column name
colnames(x)[colnames(x)=="RECENT_GENERAL_CAUSE_CODE_3"]<-"GENRD3" #Change column name
colnames(x)[colnames(x)=="RECENT_SPECIFIC_CAUSE_CODE_3"]<-"RD3" #Change column name
colnames(x)[colnames(x)=="FRAGMENT_YN"]<-"Fragment" #Change column name
colnames(x)[colnames(x)=="COND"]<-"CONDITION_1" #Change column name
#Add column for method type
x$METHOD<-"DIVER"
if(DEBUG){head(x)}
#DIVER/ADULT: Merge Diver/Adult data and SURVEY MASTER -------------------------------------
#SURVEY MASTER was created by Ivor and Courtney by extracting sites directly from the Site Visit table from Oracle. It should be the complete list of sites surveyed since 2000
#survey_master<-read.csv("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/data/SURVEY MASTER.csv")
setwd("C:/Users/Corinne.Amir/Documents/GitHub/Benthic-Scripts/SfM")
survey_master <- read.csv("SURVEY MASTER.csv")
#Check that OBS_YEAR, SITEVISITID, and SITE are all the same in both x and survey master
OYerror=which(x$OBS_YEAR!=survey_master$OBS_YEAR[match(x$SITEVISITID,survey_master$SITEVISITID)])
SIerror=which(as.vector(x$SITE)!=survey_master$SITE[match(x$SITEVISITID,survey_master$SITEVISITID)])
SIOYerrors=unique(c(OYerror,SIerror))
if(length(SIOYerrors)>0){print(paste0("Warning: Raw Data disagree with Survey Master for sitevisitids: ",x$SITEVISITID[SIOYerrors]))}
#add SITE MASTER information to x
length(unique(x$SITEVISITID)) #check the number of sites in demographic data
#join 'em
x<- inner_join(x, survey_master[,c("OBS_YEAR","SITEVISITID","SITE","SEC_NAME","ANALYSIS_YEAR","bANALYSIS_SCHEME","MIN_DEPTH_M","MAX_DEPTH_M")], by=c("OBS_YEAR","SITEVISITID","SITE"))
#Ensure that all rows in X have properly assigned SEC_NAME...
####CHECK THAT all SEC_NAME are present in the survey_master file
test<-x[is.na(x$SEC_NAME), c("MISSIONID","REGION", "SITE","OBS_YEAR"),]
test<-droplevels(test);table(test$SITE,test$MISSIONID) #create a table of missing sites by missionid
if(dim(test)[1]>0) {cat("Warning: sites with MISSING SECTORS present")}   # should be 0
#Create a list of missing sites that can be imported into the SITE MASTER file if needed
test<-x[is.na(x$SEC_NAME),]
miss.sites<-ddply(test,.(OBS_YEAR,SITEVISITID,SITE,MISSIONID,REGION,REGION_NAME,ISLAND,LATITUDE,LONGITUDE,
REEF_ZONE,DEPTH_BIN,DATE_,EXCLUDE_FLAG,HABITAT_CODE),
summarize,temp=median(SITEVISITID),SITE_MAX_DEPTH=median(SITE_MAX_DEPTH),SITE_MIN_DEPTH=median(SITE_MIN_DEPTH))
#Should be a 0 row data.frame
head(miss.sites,20)
#DIVER/ADULT: CLEAN UP ----------------------------------------------------------------
#Generate General RD cause code
gencodes<-read.csv("T:/Benthic/Data/Lookup Tables/GeneralRDcode_lookup.csv")
head(x)
levels(x$RD1)
#Remove exisiting GENRD columns until Michael can fix database
x<-subset(x,select=-c(GENRD1,GENRD2,GENRD3))
x<- droplevels(x)
x<-CreateGenRDCode(x,"RD1","GENRD1",gencodes) #Creates an additional column in x (called GENRD#) that has the generalized code associated with the given RD#--ok
x<-CreateGenRDCode(x,"RD2","GENRD2",gencodes)
x<-CreateGenRDCode(x,"RD3","GENRD3",gencodes)
x <- droplevels(x)
head(x)
##Remove sites that were only surveyed for photoquads but not demographics
#Note-photoquad only sites are not included in data prior to 2018
#Test whether there are missing values in the NO_SURVEY_YN column. The value should be 0 or -1
x.na<-x[is.na(x$NO_SURVEY_YN)&x$OBS_YEAR>2013,]
x.na
# test<-ddply(x.na,.(SITE),
#             summarize,
#             SEG=length(unique(SEGMENT)))
# test
x$NO_SURVEY_YN[is.na(x$NO_SURVEY_YN)]<-0 #Change NAs (blank cells) to 0
##Acutally do the removal of transects that were only surveyed for photoquads but not demographics
x<-subset(x,NO_SURVEY_YN==0)
#TEMPORARY FIX-SPEAK WITH DM TO CORRECT IN ORACLE
x<-subset(x,SEGLENGTH!="NA") #Remove segments that were not surveyed for coral demography (no SEGLENGTH=0 in db)
#Actually remove special missions.
x<-subset(x,EXCLUDE_FLAG==0);
# this dataframe should be empty
head(subset(x,EXCLUDE_FLAG==-1))
head(x)
#Change NAs in RecentDead extent to 0
head(subset(x,S_ORDER=="Scleractinia" & is.na(x$RDEXTENT1))) #identify columns that have NAs
x$RDEXTENT1<-ifelse(x$S_ORDER=="Scleractinia"& is.na(x$RDEXTENT1),0,x$RDEXTENT1)
head(subset(x,S_ORDER=="Scleractinia" & is.na(x$RDEXTENT2))) #identify columns that have NAs
x$RDEXTENT2<-ifelse(x$S_ORDER=="Scleractinia"& is.na(x$RDEXTENT2),0,x$RDEXTENT2)
head(subset(x,S_ORDER=="Scleractinia" & is.na(x$RDEXTENT3))) #identify columns that have NAs
x$RDEXTENT3<-ifelse(x$S_ORDER=="Scleractinia"& is.na(x$RDEXTENT3),0,x$RDEXTENT3)
#DIVER/ADULT: Assign TAXONCODE --------------------------------------------------------
#read in list of taxa that we feel comfortable identifying to species or genus level. Note, taxa lists vary by year and region. This will need to be updated through time.
taxa<-read.csv("T:/Benthic/Data/Lookup Tables/2013-19_Taxa_MASTER.csv")
#Convert SPCODE in raw colony data to TAXONCODE -generates a look up table
#x$TAXONCODE<-Convert_to_Taxoncode_tom(data = x,taxamaster = taxa)#not working need to ask tom
taxa$OBS_YEAR<-as.numeric(as.character(taxa$OBS_YEAR))
x$SPCODE<-ifelse(x$NO_COLONY_==-1,"AAAA",as.character(x$SPCODE))
#DIVER/ADULT: Assign TAXONCODE --------------------------------------------------------
#read in list of taxa that we feel comfortable identifying to species or genus level. Note, taxa lists vary by year and region. This will need to be updated through time.
taxa<-read.csv("T:/Benthic/Data/Lookup Tables/2013-19_Taxa_MASTER.csv")
#Convert SPCODE in raw colony data to TAXONCODE -generates a look up table
#x$TAXONCODE<-Convert_to_Taxoncode_tom(data = x,taxamaster = taxa)#not working need to ask tom
taxa$OBS_YEAR<-as.numeric(as.character(taxa$OBS_YEAR))
x$SPCODE<-ifelse(x$NO_COLONY_==-1,"AAAA",as.character(x$SPCODE))
#Actually remove special missions.
x<-subset(x,EXCLUDE_FLAG==0);
