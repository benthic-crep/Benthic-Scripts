analyst.per.ss <- filter(analyst.per.ss, num.analyst>1)
View(analyst.per.ss)
# SFM/JUVENILE: CLEAN ANALYSIS READY DATA -------------------------------------
df<-read.csv("T:/Benthic/Data/SfM/Calibration QC/MARAMP2022_QCdsfm_JUV_CALIB.csv") #851 rows
x<-df
head(x)
View(x)
#SFM/JUVENILE: Column Names Changes... -------------------------------------------------
colnames(x)[colnames(x)=="FRAGMENT.1"]<-"Fragment" #Change column name
colnames(x)[colnames(x)=="Shape_Length"]<-"COLONYLENGTH" #Change column name
colnames(x)[colnames(x)=="OID_"]<-"COLONYID" #Change column name
#SFM/JUVENILE: Column Names Changes... -------------------------------------------------
colnames(x)[colnames(x)=="FRAGMENT.1"]<-"FRAGMENT" #Change column name
colnames(x)[colnames(x)=="Shape_Length"]<-"COLONYLENGTH" #Change column name
colnames(x)[colnames(x)=="OID_"]<-"COLONYID" #Change column name
#Add column for method type
x$METHOD<-"SfM"
if(DEBUG){head(x)}
x<-df
head(x)
View(x)
nrow(x)
#SFM/JUVENILE: Column Names Changes... -------------------------------------------------
colnames(x)[colnames(x)=="FRAGMENT.1"]<-"FRAGMENT" #Change column name
colnames(x)[colnames(x)=="Shape_Length"]<-"COLONYLENGTH" #Change column name
colnames(x)[colnames(x)=="OID_"]<-"COLONYID" #Change column name
#Add column for method type
x$METHOD<-"SfM"
if(DEBUG){head(x)}
table(x$SITE,x$ANALYST)
x
#Fill in columns with values that we know should not be different across any of the rows
x$OBS_YEAR <- as.vector(rep(2022, times = nrow(x)))
x$COLONYLENGTH<-x$COLONYLENGTH*100 #convert from m to cm
x$S_ORDER<-ifelse(x$NO_COLONY_==0 & x$SPCODE!="NONE","Scleractinia","NONE") #add S_order column
#Create Genuscode and taxonname column from spcode
genlookup<-read.csv("T:/Benthic/Data/Lookup Tables/Genus_lookup.csv")
x<-CreateGenusCode(x,genlookup)
x<-df
#SFM/JUVENILE: Column Names Changes... -------------------------------------------------
colnames(x)[colnames(x)=="FRAGMENT.1"]<-"Fragment" #Change column name
colnames(x)[colnames(x)=="Shape_Length"]<-"COLONYLENGTH" #Change column name
colnames(x)[colnames(x)=="OID_"]<-"COLONYID" #Change column name
#Add column for method type
x$METHOD<-"SfM"
if(DEBUG){head(x)}
table(x$SITE,x$ANALYST)
#Fill in columns with values that we know should not be different across any of the rows
x$OBS_YEAR <- as.vector(rep(2022, times = nrow(x)))
x$COLONYLENGTH<-x$COLONYLENGTH*100 #convert from m to cm
x$S_ORDER<-ifelse(x$NO_COLONY_==0 & x$SPCODE!="NONE","Scleractinia","NONE") #add S_order column
x$S_ORDER<-ifelse(x$NO_COLONY==0 & x$SPCODE!="NONE","Scleractinia","NONE") #add S_order column
#Create Genuscode and taxonname column from spcode
genlookup<-read.csv("T:/Benthic/Data/Lookup Tables/Genus_lookup.csv")
x<-CreateGenusCode(x,genlookup)
head(x)
#SFM/JUVENILE: Assign TAXONCODE --------------------------------------------------------
#read in list of taxa that we feel comfortable identifying to species or genus level. Note, taxa lists vary by year and region. This will need to be updated through time.
taxa<-read.csv("T:/Benthic/Data/Lookup Tables/2013-22_Taxa_MASTER.csv")
taxa$OBS_YEAR<-as.numeric(as.character(taxa$OBS_YEAR))
x$SPCODE<-ifelse(x$NO_COLONY_==-1,"AAAA",as.character(x$SPCODE))
x$SPCODE<-ifelse(x$NO_COLONY==-1,"AAAA",as.character(x$SPCODE))
x$REGION <- "MARIAN"
#Convert SPCODE in raw colony data to TAXONCODE -generates a look up table
x$TAXONCODE<-Convert_to_Taxoncode(x,taxa)
#Check to make sure SPCODE was converted correctly
head(x[x$SPCODE!=x$TAXONCODE,])
#Check to see whether S_ORDER is NA and not AAAA (the code for no colonies observed on the segment)
x[x$SPCODE!="AAAA"& is.na(x$S_ORDER),] #this dataframe should be empty
#Change columns to character
x$GENUS_CODE<-as.character(x$GENUS_CODE)
x$SPCODE<-as.character(x$SPCODE)
x$TAXONCODE<-as.character(x$TAXONCODE)
x$S_ORDER<-as.character(x$S_ORDER)
#Make sure there are no NA values in genus code or taxoncode if it's supposed to be a scleractinian
subset(x,S_ORDER=="Scleractinia" & GENUS_CODE=="NA") #this dataframe should be empty
subset(x,S_ORDER=="Scleractinia" & TAXONCODE=="NA") #this dataframe should be empty
#There are some old SPCODES that were a combination of taxa and weren't included in the complete taxa list
#Change these unknown genera or taxoncodes to the spcode and the remaining NAs in the Taxon and genus code to AAAA
x$GENUS_CODE<-ifelse(x$TAXONCODE=="UNKN","UNKN",x$GENUS_CODE)
x$TAXONCODE<-ifelse(x$SPCODE=="AAAA","AAAA",x$TAXONCODE)
x$GENUS_CODE<-ifelse(x$TAXONCODE=="AAAA","AAAA",x$GENUS_CODE)
#Check that Unknown scl were changed correctly
head(subset(x,TAXONCODE=="UNKN"&S_ORDER=="Scleractinia"),40)
head(subset(x,GENUS_CODE=="UNKN"&S_ORDER=="Scleractinia"))
head(subset(x,GENUS_CODE=="AAAA"))
head(subset(x,SPCODE=="AAAA"))
#In order to record no colonies observed in a segment, we need to create a small colony on the image.This code removes that size measure
x$COLONYLENGTH<-ifelse(x$SPCODE=="AAAA",0,as.character(x$COLONYLENGTH))
#Remove colonies with EX_BOUND = -1
x <- subset(x, EX_BOUND==0)
# sapply(x,levels)
head(x)
nrow(x)
#Reorder columns
x<-x[,c("METHOD","ANALYST", "REGION","OBS_YEAR","SITE","SEGMENT","SEGLENGTH","SEGWIDTH",
"SEGAREA","COLONYID","Fragment","S_ORDER","GENUS_CODE","SPCODE","TAXONCODE","TAXONNAME",
"EX_BOUND","COLONYLENGTH")]
## CLEAN UP NAs ##
NegNineCheckCols=c("S_ORDER","TAXONNAME","MIN_DEPTH_M","MAX_DEPTH_M","COLONYLENGTH")
x[,NegNineCheckCols][x[,NegNineCheckCols] ==-9] <- NA #Convert missing numeric values to NA (they are entered as -9 in Oracle)
#CALIB FILTERING
x<-x[,c("METHOD","ANALYST", "REGION","OBS_YEAR","SITE","SEGMENT","SEGLENGTH","SEGWIDTH",
"SEGAREA","COLONYID","Fragment","S_ORDER","GENUS_CODE","SPCODE","TAXONCODE","TAXONNAME",
"EX_BOUND","COLONYLENGTH")]
## CLEAN UP NAs ##
#NegNineCheckCols=c("S_ORDER","TAXONNAME","MIN_DEPTH_M","MAX_DEPTH_M","COLONYLENGTH")
NegNineCheckCols=c("S_ORDER","TAXONNAME","COLONYLENGTH")
x[,NegNineCheckCols][x[,NegNineCheckCols] ==-9] <- NA #Convert missing numeric values to NA (they are entered as -9 in Oracle)
jwd<-droplevels(x)
write.csv(jwd,file="T:/Benthic/Data/SfM/Calibration QC/MARAMP22_SfMJuv_CLEANED.csv",row.names = F)
View(jwd)
#Check number of Site-Segments that contain at least 2 divers ----------------------------------------------------
analyst.per.ss <- ddply(x,.(SITE, SEGMENT), summarize, num.analyst = n_distinct(ANALYST))
analyst.per.ss <- filter(analyst.per.ss, num.analyst>1)
View(analyst.per.ss)
rm(list=ls())
#LOAD LIBRARY FUNCTIONS ...
source("C:/Users/Jonathan.Charendoff/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_newApp_vTAOfork.R")
source("C:/Users/Jonathan.Charendoff/Documents/GitHub/Benthic-Scripts/Functions/core_functions.R")
#Read in files
ad_sfm<-read.csv("T:/Benthic/Data/SfM/Calibration QC/MARAMP22_SfMAdult_CLEANED.csv")
j_sfm<-read.csv("T:/Benthic/Data/SfM/Calibration QC/MARAMP22_SfMJuv_CLEANED.csv")
#Check number of unique site-segments
t1<-ddply(ad_sfm,.(SITE,SEGMENT),summarize,n=length(unique(ANALYST)))
t2<-ddply(j_sfm,.(SITE,SEGMENT),summarize,n=length(unique(ANALYST)))
###FOR CALIBRATION: Use this script to assign transect
#Create Transect column and use this to code duplicate segments
ad_sfm<-ad_sfm %>% mutate(TRANSECT=recode(ANALYST,
`JC`="1",
`MSL`="2",
`NBO`="3",
`NA`="NA"))
#Check that segments were changed correctly
ad_sfm<-droplevels(ad_sfm)
table(ad_sfm$SITE,ad_sfm$TRANSECT)
#Create Transect column and use this to code duplicate segments
j_sfm<-j_sfm %>% mutate(TRANSECT=recode(ANALYST,
`JC`="1",
`MSL`="2",
`NBO`="3",
`NA`="NA"))
#Check that segments were changed correctly
j_sfm<-droplevels(j_sfm)
table(j_sfm$SITE,j_sfm$TRANSECT)
##Calcuate segment and transect area and add column for transect area
ad_sfm$MISSIONID<-"RA2201"
j_sfm$MISSIONID<-"RA2201"
ad_sfm$TRANSECTAREA<-Transectarea(ad_sfm) #check if needed
View(ad_sfm)
ad_sfm$TRANSECTAREA<-ad_sfm$SEGAREA
j_sfm$TRANSECTAREA<-j_sfm$SEGAREA
#Check if any site-segments have been dropped
t1<-ddply(ad_sfm,.(SITE,SEGMENT),summarize,n=length(unique(ANALYST)));nrow(t1[t1$n>1,])
t1<-ddply(j_sfm,.(SITE,SEGMENT),summarize,n=length(unique(ANALYST)));nrow(t1[t1$n>1,])
t2<-ddply(j_sfm,.(SITE,SEGMENT),summarize,n=length(unique(ANALYST)));nrow(t1[t1$n>1,])
# GENERATE SUMMARY METRICS at the Segment-leveL BY GENUS--------------------------------------------------
#REMOVE COLONIES THAT COULD'T BE FULLY ANNOTATED IN SFM
ad_sfm<-subset(ad_sfm,EX_BOUND==0) #don't worry about for now
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = ad_sfm,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
require(dplyr)
require(plyr)
require(reshape2)
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = ad_sfm,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
# SFM/ADULT: CLEAN ANALYSIS READY DATA ----------------------------------------------------
df<-read.csv("T:/Benthic/Data/SfM/Calibration QC/MARAMP2022_QCdsfm_ADULT_CALIB.csv")
x<-df
head(x)
View(x)
colnames(x)[colnames(x)=="RD_1"]<-"RDEXTENT1" #Change column name
colnames(x)[colnames(x)=="RDCAUSE1"]<-"RD1" #Change column name
colnames(x)[colnames(x)=="RD_2"]<-"RDEXTENT2" #Change column name
colnames(x)[colnames(x)=="RD_3"]<-"RDEXTENT3" #Change column name
colnames(x)[colnames(x)=="RDCAUSE2"]<-"RD2" #Change column name
colnames(x)[colnames(x)=="RDCAUSE3"]<-"RD3" #Change column name
colnames(x)[colnames(x)=="FRAGMENT_Y"]<-"Fragment" #Change column name
colnames(x)[colnames(x)=="CON_1"]<-"CONDITION_1" #Change column name
colnames(x)[colnames(x)=="CON_2"]<-"CONDITION_2" #Change column name
colnames(x)[colnames(x)=="CON_3"]<-"CONDITION_3" #Change column name
colnames(x)[colnames(x)=="SEV_1"]<-"SEVERITY_1" #Change column name
colnames(x)[colnames(x)=="SEV_2"]<-"SEVERITY_2" #Change column name
colnames(x)[colnames(x)=="SEV_3"]<-"SEVERITY_3" #Change column name
colnames(x)[colnames(x)=="Shape_Length"]<-"COLONYLENGTH" #Change column name
colnames(x)[colnames(x)=="OID_"]<-"COLONYID" #Change column name
#Add column for method type
x$METHOD<-"SfM"
if(DEBUG){head(x)}
table(x$SITE,x$ANALYST)
x$OBS_YEAR <- as.vector(rep(2022, times = nrow(x)))
x$COLONYLENGTH<-x$COLONYLENGTH*100 #convert from m to cm
x$S_ORDER<-ifelse(x$NO_COLONY==0 | x$SPCODE!="NONE","Scleractinia","NONE") #add S_order column
x$SEGAREA <-2.5 #shoudln't have been removed in QC step
#Create Genuscode and taxonname column from spcode
genlookup<-read.csv("T:/Benthic/Data/Lookup Tables/Genus_lookup.csv")
x<-CreateGenusCode(x,genlookup)
head(x)
#Generate General RD cause code
gencodes<-read.csv("T:/Benthic/Data/Lookup Tables/GeneralRDcode_lookup.csv")
head(x)
levels(x$RD1)
x<-CreateGenRDCode(x,"RD1","GENRD1",gencodes)
x<-CreateGenRDCode(x,"RD2","GENRD2",gencodes)
x<-CreateGenRDCode(x,"RD3","GENRD3",gencodes)
head(x)
nrow(df);nrow(x) #make sure rows weren't dropped
#SfM/ADULT: Merge Adult data and  SURVEY MASTER  -------------------------------------
#survey_master<-read.csv("C:/Users/Courtney.S.Couch/Documents/GitHub/fish-paste/data/SURVEY MASTER.csv")
setwd("C:/Users/Jonathan.Charendoff/Documents/GitHub/Benthic-Scripts/SfM")
survey_master <- read.csv("TEMP SURVEY MASTER NOT FOR ANALYSIS.csv")
View(survey_master)
survey_master <- read.csv("TEMP SURVEY MASTER NOT FOR ANALYSIS.csv")[1:5,]
View(survey_master)
colnames(survey_master)[colnames(survey_master)=="LATITUDE_SV"]<-"LATITUDE" #Change column name
colnames(survey_master)[colnames(survey_master)=="LONGITUDE_SV"]<-"LONGITUDE" #Change column name
x<-left_join(x,survey_master[,c("REGION","OBS_YEAR","ISLAND","SITEVISITID","SITE","SEC_NAME",
"REEF_ZONE","DEPTH_BIN","HABITAT_CODE","LATITUDE","LONGITUDE","MIN_DEPTH_M","MAX_DEPTH_M")],by=c("OBS_YEAR","SITE"))
head(x)
nrow(x)
#SfM/ADULT: Assign TAXONCODE --------------------------------------------------------
#read in list of taxa that we feel comfortable identifying to species or genus level. Note, taxa lists vary by year and region. This will need to be updated through time.
taxa<-read.csv("T:/Benthic/Data/Lookup Tables/2013-22_Taxa_MASTER.csv") #change when final name is made
taxa$OBS_YEAR<-as.numeric(as.character(taxa$OBS_YEAR))
x$REGION <- "MARIAN"
x$SPCODE<-ifelse(x$NO_COLONY==-1,"AAAA",as.character(x$SPCODE))
#Convert SPCODE in raw colony data to TAXONCODE -generates a look up table
x$TAXONCODE<-Convert_to_Taxoncode(x,taxa)
#Check to make sure SPCODE was converted correctly
head(x[x$SPCODE!=x$TAXONCODE,])
#If there are issues use this code to create a list SPCODE (lowest taxonomic resolution we have), TAXONCODE (the taxonomic level we all feel comfortable with) and associated genera
#This is used for spot checking that TAXONCODE was converted properly & can be compared against TAXA MASTER
SURVEY_INFO<-c("OBS_YEAR","REGION","SPCODE","TAXONCODE","GENUS_CODE","TAXONNAME")
test<-new_Aggregate_InputTable(x, SURVEY_INFO)
#Check to see whether S_ORDER is NA and not AAAA (the code for no colonies observed on the segment)
x[x$SPCODE!="AAAA"& is.na(x$S_ORDER),] #this dataframe should be empty
#Change columns to character
x$GENUS_CODE<-as.character(x$GENUS_CODE)
x$SPCODE<-as.character(x$SPCODE)
x$TAXONCODE<-as.character(x$TAXONCODE)
x$S_ORDER<-as.character(x$S_ORDER)
x$COLONYLENGTH <- as.numeric(x$COLONYLENGTH)
#Make sure there are no NA values in genus code or taxoncode if it's supposed to be a scleractinian
subset(x,S_ORDER=="Scleractinia" & GENUS_CODE=="NA") #this dataframe should be empty
subset(x,S_ORDER=="Scleractinia" & TAXONCODE=="NA") #this dataframe should be empty
#There are some old SPCODES that were a combination of taxa and weren't included in the complete taxa list
#Change these unknown genera or taxoncodes to the spcode and the remaining NAs in the Taxon and genus code to AAAA
x$GENUS_CODE<-ifelse(x$TAXONCODE=="UNKN","UNKN",x$GENUS_CODE)
x$TAXONCODE<-ifelse(x$SPCODE=="AAAA","AAAA",x$TAXONCODE)
x$GENUS_CODE<-ifelse(x$TAXONCODE=="AAAA","AAAA",x$GENUS_CODE)
View(x) #view data in separate window
#Check that Unknown scl were changed correctly
head(subset(x,TAXONCODE=="UNKN"&S_ORDER=="Scleractinia"),40)
head(subset(x,GENUS_CODE=="UNKN"&S_ORDER=="Scleractinia"))
head(subset(x,GENUS_CODE=="AAAA"))
head(subset(x,SPCODE=="AAAA"))
#In order to record no colonies observed in a segment, we need to create a small colony on the image.This code removes that size measure
x$COLONYLENGTH<-ifelse(x$SPCODE=="AAAA",0,as.character(x$COLONYLENGTH))
#Reorder columns
x<-x[,c("METHOD","ANALYST", "REGION","OBS_YEAR","ISLAND","SEC_NAME","SITEVISITID","SITE","REEF_ZONE","DEPTH_BIN",
"HABITAT_CODE","LATITUDE","LONGITUDE","MIN_DEPTH_M","MAX_DEPTH_M","SEGMENT","SEGLENGTH","SEGWIDTH",
"SEGAREA","COLONYID","Fragment","S_ORDER","GENUS_CODE","SPCODE","TAXONCODE","TAXONNAME",
"EX_BOUND","COLONYLENGTH","OLDDEAD","GENRD1","GENRD2","GENRD3","RD1","RDEXTENT1","RD2","RDEXTENT2","RD3",
"RDEXTENT3","CONDITION_1","EXTENT_1","SEVERITY_1","CONDITION_2","EXTENT_2","SEVERITY_2","CONDITION_3","EXTENT_3","SEVERITY_3")]
View(x)
#Reorder columns
x<-x[,c("METHOD","ANALYST", "REGION","OBS_YEAR","ISLAND","SEC_NAME","SITEVISITID","SITE","REEF_ZONE","DEPTH_BIN",
"HABITAT_CODE","LATITUDE","LONGITUDE","MIN_DEPTH_M","MAX_DEPTH_M","SEGMENT","SEGLENGTH","SEGWIDTH",
"SEGAREA","COLONYID","Fragment","S_ORDER","GENUS_CODE","SPCODE","TAXONCODE","TAXONNAME",
"EX_BOUND","COLONYLENGTH","OLD_DEAD","GENRD1","GENRD2","GENRD3","RD1","RDEXTENT1","RD2","RDEXTENT2","RD3",
"RDEXTENT3","CONDITION_1","EXTENT_1","SEVERITY_1","CONDITION_2","EXTENT_2","SEVERITY_2","CONDITION_3","EXTENT_3","SEVERITY_3")]
#Reorder columns
x<-x[,c("METHOD","ANALYST", "REGION","OBS_YEAR","ISLAND","SEC_NAME","SITEVISITID","SITE","REEF_ZONE","DEPTH_BIN",
"HABITAT_CODE","LATITUDE","LONGITUDE","MIN_DEPTH_M","MAX_DEPTH_M","SEGMENT","SEGLENGTH","SEGWIDTH",
"SEGAREA","COLONYID","FRAGMENT","S_ORDER","GENUS_CODE","SPCODE","TAXONCODE","TAXONNAME",
"EX_BOUND","COLONYLENGTH","OLD_DEAD","GENRD1","GENRD2","GENRD3","RD1","RDEXTENT1","RD2","RDEXTENT2","RD3",
"RDEXTENT3","CONDITION_1","EXTENT_1","SEVERITY_1","CONDITION_2","EXTENT_2","SEVERITY_2","CONDITION_3","EXTENT_3","SEVERITY_3")]
## CLEAN UP NAs ##
NegNineCheckCols=c("RDEXTENT1","GENRD1","RD1","RDEXTENT2","GENRD2","RD2","GENRD3","RD3",
"RDEXTENT3","CONDITION_1","CONDITION_2","CONDITION_3","EXTENT_1","EXTENT_2","EXTENT_3","SEVERITY_1",
"SEVERITY_2","SEVERITY_3","GENUS_CODE","S_ORDER")
x[,NegNineCheckCols][x[,NegNineCheckCols]==-9] <- NA #Convert missing numeric values to NA (they are entered as -9 in Oracle)
#SfM/ADULT: Clean up NAs ------------------------------------------------------------
tmp.lev<-levels(x$GENRD1); tmp.lev
x[is.na(x$GENRD1),"GENRD1"]<-"NONE"
x[is.na(x$RD1),"RD1"]<-"NONE"
x[is.na(x$GENRD2),"GENRD2"]<-"NONE"
x[is.na(x$RD2),"RD2"]<-"NONE"
x[is.na(x$GENRD3),"GENRD3"]<-"NONE"
x[is.na(x$RD3),"RD3"]<-"NONE"
x[is.na(x$CONDITION_1),"CONDITION_1"]<-"NONE"
x[is.na(x$CONDITION_2),"CONDITION_2"]<-"NONE"
x[is.na(x$CONDITION_3),"CONDITION_3"]<-"NONE"
head(x)
awd<-droplevels(x)
write.csv(awd,file="T:/Benthic/Data/SfM/Calibration QC/MARAMP22_SfMAdult_CLEANED.csv",row.names = F)
# SFM/JUVENILE: CLEAN ANALYSIS READY DATA -------------------------------------
df<-read.csv("T:/Benthic/Data/SfM/Calibration QC/MARAMP2022_QCdsfm_JUV_CALIB.csv") #851 rows
x<-df
head(x)
View(x)
#SFM/JUVENILE: Column Names Changes... -------------------------------------------------
colnames(x)[colnames(x)=="FRAGMENT.1"]<-"Fragment" #Change column name
View(x)
#SFM/JUVENILE: Column Names Changes... -------------------------------------------------
colnames(x)[colnames(x)=="FRAGMENT"]<-"Fragment" #Change column name
colnames(x)[colnames(x)=="Shape_Length"]<-"COLONYLENGTH" #Change column name
colnames(x)[colnames(x)=="OID_"]<-"COLONYID" #Change column name
#Add column for method type
x$METHOD<-"SfM"
if(DEBUG){head(x)}
table(x$SITE,x$ANALYST)
#Fill in columns with values that we know should not be different across any of the rows
x$OBS_YEAR <- as.vector(rep(2022, times = nrow(x)))
x$COLONYLENGTH<-x$COLONYLENGTH*100 #convert from m to cm
x$S_ORDER<-ifelse(x$NO_COLONY==0 & x$SPCODE!="NONE","Scleractinia","NONE") #add S_order column
#Create Genuscode and taxonname column from spcode
genlookup<-read.csv("T:/Benthic/Data/Lookup Tables/Genus_lookup.csv")
x<-CreateGenusCode(x,genlookup)
# SFM/JUVENILE: CLEAN ANALYSIS READY DATA -------------------------------------
df<-read.csv("T:/Benthic/Data/SfM/Calibration QC/MARAMP2022_QCdsfm_JUV_CALIB.csv") #851 rows
x<-df
head(x)
#SFM/JUVENILE: Column Names Changes... -------------------------------------------------
#colnames(x)[colnames(x)=="FRAGMENT"]<-"Fragment" #Change column name
colnames(x)[colnames(x)=="Shape_Length"]<-"COLONYLENGTH" #Change column name
colnames(x)[colnames(x)=="OID_"]<-"COLONYID" #Change column name
#Add column for method type
x$METHOD<-"SfM"
if(DEBUG){head(x)}
table(x$SITE,x$ANALYST)
#Fill in columns with values that we know should not be different across any of the rows
x$OBS_YEAR <- as.vector(rep(2022, times = nrow(x)))
x$COLONYLENGTH<-x$COLONYLENGTH*100 #convert from m to cm
x$S_ORDER<-ifelse(x$NO_COLONY==0 & x$SPCODE!="NONE","Scleractinia","NONE") #add S_order column
#Create Genuscode and taxonname column from spcode
genlookup<-read.csv("T:/Benthic/Data/Lookup Tables/Genus_lookup.csv")
x<-CreateGenusCode(x,genlookup)
head(x)
x<-left_join(x,survey_master[,c("REGION","OBS_YEAR","ISLAND","SITEVISITID","SITE","SEC_NAME",
"REEF_ZONE","DEPTH_BIN","HABITAT_CODE","LATITUDE","LONGITUDE","MIN_DEPTH_M","MAX_DEPTH_M")],by=c("OBS_YEAR","SITE"))
head(x)
nrow(x)
#SFM/JUVENILE: Assign TAXONCODE --------------------------------------------------------
#read in list of taxa that we feel comfortable identifying to species or genus level. Note, taxa lists vary by year and region. This will need to be updated through time.
taxa<-read.csv("T:/Benthic/Data/Lookup Tables/2013-22_Taxa_MASTER.csv")
taxa$OBS_YEAR<-as.numeric(as.character(taxa$OBS_YEAR))
x$SPCODE<-ifelse(x$NO_COLONY==-1,"AAAA",as.character(x$SPCODE))
x$REGION <- "MARIAN"
#Convert SPCODE in raw colony data to TAXONCODE -generates a look up table
x$TAXONCODE<-Convert_to_Taxoncode(x,taxa)
#Check to make sure SPCODE was converted correctly
head(x[x$SPCODE!=x$TAXONCODE,])
#Check to see whether S_ORDER is NA and not AAAA (the code for no colonies observed on the segment)
x[x$SPCODE!="AAAA"& is.na(x$S_ORDER),] #this dataframe should be empty
#Change columns to character
x$GENUS_CODE<-as.character(x$GENUS_CODE)
x$SPCODE<-as.character(x$SPCODE)
x$TAXONCODE<-as.character(x$TAXONCODE)
x$S_ORDER<-as.character(x$S_ORDER)
#Make sure there are no NA values in genus code or taxoncode if it's supposed to be a scleractinian
subset(x,S_ORDER=="Scleractinia" & GENUS_CODE=="NA") #this dataframe should be empty
subset(x,S_ORDER=="Scleractinia" & TAXONCODE=="NA") #this dataframe should be empty
#There are some old SPCODES that were a combination of taxa and weren't included in the complete taxa list
#Change these unknown genera or taxoncodes to the spcode and the remaining NAs in the Taxon and genus code to AAAA
x$GENUS_CODE<-ifelse(x$TAXONCODE=="UNKN","UNKN",x$GENUS_CODE)
x$TAXONCODE<-ifelse(x$SPCODE=="AAAA","AAAA",x$TAXONCODE)
#Check that Unknown scl were changed correctly
head(subset(x,TAXONCODE=="UNKN"&S_ORDER=="Scleractinia"),40)
head(subset(x,GENUS_CODE=="UNKN"&S_ORDER=="Scleractinia"))
head(subset(x,GENUS_CODE=="AAAA"))
head(subset(x,SPCODE=="AAAA"))
#In order to record no colonies observed in a segment, we need to create a small colony on the image.This code removes that size measure
x$COLONYLENGTH<-ifelse(x$SPCODE=="AAAA",0,as.character(x$COLONYLENGTH))
#Remove colonies with EX_BOUND = -1
x <- subset(x, EX_BOUND==0)
nrow(x)
#Reorder columns
x<-x[,c("METHOD","ANALYST", "REGION","OBS_YEAR","ISLAND","SEC_NAME","SITEVISITID","SITE","REEF_ZONE","DEPTH_BIN",
"HABITAT_CODE","LATITUDE","LONGITUDE","MIN_DEPTH_M","MAX_DEPTH_M","SEGMENT","SEGLENGTH","SEGWIDTH",
"SEGAREA","COLONYID","FRAGMENT","S_ORDER","GENUS_CODE","SPCODE","TAXONCODE","TAXONNAME",
"EX_BOUND","COLONYLENGTH")]
## CLEAN UP NAs ##
#NegNineCheckCols=c("S_ORDER","TAXONNAME","MIN_DEPTH_M","MAX_DEPTH_M","COLONYLENGTH")
NegNineCheckCols=c("S_ORDER","TAXONNAME","COLONYLENGTH")
x[,NegNineCheckCols][x[,NegNineCheckCols] ==-9] <- NA #Convert missing numeric values to NA (they are entered as -9 in Oracle)
## CLEAN UP NAs ##
NegNineCheckCols=c("S_ORDER","TAXONNAME","MIN_DEPTH_M","MAX_DEPTH_M","COLONYLENGTH")
x[,NegNineCheckCols][x[,NegNineCheckCols] ==-9] <- NA #Convert missing numeric values to NA (they are entered as -9 in Oracle)
jwd<-droplevels(x)
write.csv(jwd,file="T:/Benthic/Data/SfM/Calibration QC/MARAMP22_SfMJuv_CLEANED.csv",row.names = F)
analyst.per.ss <- ddply(x,.(SITE, SEGMENT), summarize, num.analyst = n_distinct(ANALYST))
analyst.per.ss <- filter(analyst.per.ss, num.analyst>1)
View(analyst.per.ss)
# source("C:/Users/Corinne.Amir/Documents/GitHub/Benthic-Scripts/Functions/Benthic_Functions_newApp_vTAOfork.R")
# source("C:/Users/Corinne.Amir/Documents/GitHub/fish-paste/lib/core_functions.R")
# source("C:/Users/Corinne.Amir/Documents/GitHub/fish-paste/lib/GIS_functions.R")
source("C:/Users/jonathan.charendoff/Downloads/core_functions.R")
#Read in files
ad_sfm<-read.csv("T:/Benthic/Data/SfM/Calibration QC/MARAMP22_SfMAdult_CLEANED.csv")
j_sfm<-read.csv("T:/Benthic/Data/SfM/Calibration QC/MARAMP22_SfMJuv_CLEANED.csv")
#Check number of unique site-segments
t1<-ddply(ad_sfm,.(SITE,SEGMENT),summarize,n=length(unique(ANALYST)))
t2<-ddply(j_sfm,.(SITE,SEGMENT),summarize,n=length(unique(ANALYST)))
t1
t2
###FOR CALIBRATION: Use this script to assign transect
#Create Transect column and use this to code duplicate segments
ad_sfm<-ad_sfm %>% mutate(TRANSECT=recode(ANALYST,
`JC`="1",
`MSL`="2",
`NBO`="3",
`NA`="NA"))
#Check that segments were changed correctly
ad_sfm<-droplevels(ad_sfm)
table(ad_sfm$SITE,ad_sfm$TRANSECT)
#Create Transect column and use this to code duplicate segments
j_sfm<-j_sfm %>% mutate(TRANSECT=recode(ANALYST,
`JC`="1",
`MSL`="2",
`NBO`="3",
`NA`="NA"))
#Check that segments were changed correctly
j_sfm<-droplevels(j_sfm)
table(j_sfm$SITE,j_sfm$TRANSECT)
##Calcuate segment and transect area and add column for transect area
ad_sfm$MISSIONID<-"RA2201"
j_sfm$MISSIONID<-"RA2201"
ad_sfm$TRANSECTAREA<-Transectarea(ad_sfm) #check if needed
j_sfm$TRANSECTAREA<-Transectarea(j_sfm) #check if needed
ad_sfm$TRANSECTAREA<-ad_sfm$SEGAREA
j_sfm$TRANSECTAREA<-j_sfm$SEGAREA
ad_sfm$TRANSECTAREA<-Transectarea(ad_sfm) #check if needed
Transectarea(ad_sfm)
View(ad_sfm)
ad_sfm$TRANSECTAREA<-Transectarea(ad_sfm) #check if needed
j_sfm$TRANSECTAREA<-Transectarea(j_sfm) #check if needed
j_sfm$TRANSECTAREA<-Transectarea(j_sfm) #check if needed
View(j_sfm)
#Check if any site-segments have been dropped
t1<-ddply(ad_sfm,.(SITE,SEGMENT),summarize,n=length(unique(ANALYST)));nrow(t1[t1$n>1,])
t2<-ddply(j_sfm,.(SITE,SEGMENT),summarize,n=length(unique(ANALYST)));nrow(t1[t1$n>1,])
########################### 8/25/22
#Create a look up table of all of the colony attributes- you will need this for the functions below
SURVEY_COL<-c("METHOD","SITEVISITID", "OBS_YEAR", "REGION", "ISLAND","SEC_NAME", "SITE", "REEF_ZONE",
"DEPTH_BIN", "LATITUDE", "LONGITUDE","MIN_DEPTH_M","MAX_DEPTH_M","TRANSECT","SEGMENT","COLONYID","GENUS_CODE","TAXONCODE","SPCODE","COLONYLENGTH")
survey_colony<-unique(ad_sfm[,SURVEY_COL])
SURVEY_SITE<-c("METHOD","SITEVISITID", "OBS_YEAR", "REGION", "ISLAND","SEC_NAME", "SITE", "REEF_ZONE",
"DEPTH_BIN", "LATITUDE", "LONGITUDE","MIN_DEPTH_M","MAX_DEPTH_M")
survey_site<-unique(ad_sfm[,SURVEY_SITE])
SURVEY_Seg<-c("METHOD","SITEVISITID", "OBS_YEAR", "REGION", "ISLAND","SEC_NAME", "SITE", "REEF_ZONE",
"DEPTH_BIN","HABITAT_CODE", "LATITUDE", "LONGITUDE","MIN_DEPTH_M","MAX_DEPTH_M","METHOD","TRANSECT","SEGMENT")
survey_segment<-unique(ad_sfm[,SURVEY_Seg])
#Combine juvenile and adult data
aj_sfm<-full_join(ad_sfm,j_sfm) #fixes NA problem
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = ad_sfm,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
colnames(ad_sfm)[colnames(ad_sfm)=="FRAGMENT"]<-"Fragment"
colnames(j_sfm)[colnames(j_sfm)=="FRAGMENT"]<-"Fragment"
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = ad_sfm,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
library(tidyverse)
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = ad_sfm,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
?spread
View(Calc_ColDen_Seg)
library(tidyr)
#Calc_ColDen_Transect
acd.gen<-Calc_ColDen_Seg(data = ad_sfm,grouping_field = "GENUS_CODE");colnames(acd.gen)[colnames(acd.gen)=="ColCount"]<-"AdColCount";colnames(acd.gen)[colnames(acd.gen)=="ColDen"]<-"AdColDen";colnames(acd.gen)[colnames(acd.gen)=="SEGAREA"]<-"SEGAREA_ad"# calculate density at genus level as well as total
jcd.gen<-Calc_ColDen_Seg(j_sfm,"GENUS_CODE"); colnames(jcd.gen)[colnames(jcd.gen)=="ColCount"]<-"JuvColCount";colnames(jcd.gen)[colnames(jcd.gen)=="ColDen"]<-"JuvColDen"
jcd.gen<-subset(jcd.gen,select=-c(SEGAREA))
## This function calculates mean colony length, % recent dead, % old dead, condition severity or condition extent to the segment level
## NOTE: can run both adult & juvenile data with this function for COLONYLENGTH
#c("COLONYLENGTH","RDEXTENT1", "RDEXTENT2", "RDEXTENT3", "OLDDEAD","SEVERITY_1","SEVERITY_2", "SEVERITY_3", "EXTENT_1", "EXTENT_2", "EXTENT_3")
cl.gen<-Calc_ColMetric_Seg(data = ad_sfm,grouping_field = "GENUS_CODE",pool_fields = "COLONYLENGTH"); colnames(cl.gen)[colnames(cl.gen)=="Ave.y"]<-"Ave.cl" #Average % old dead
od.gen<-Calc_ColMetric_Seg(data = ad_sfm,grouping_field = "GENUS_CODE",pool_fields = "OLD_DEAD"); colnames(od.gen)[colnames(od.gen)=="Ave.y"]<-"Ave.od" #Average % old dead
rd.gen<-Calc_ColMetric_Seg(data = ad_sfm,grouping_field = "GENUS_CODE",pool_fields = c("RDEXTENT1", "RDEXTENT2","RDEXTENT3")); colnames(rd.gen)[colnames(rd.gen)=="Ave.y"]<-"Ave.rd" #Average % recent dead
rdden.gen<-Calc_RDden_Seg(data=ad_sfm,grouping_field ="GENUS_CODE") # Density of recent dead colonies by condition, you will need to subset which ever condition you want. The codes ending in "S" are the general categories
acutedz.gen<-subset(rdden.gen,select = c(METHOD,SITEVISITID,SITE,TRANSECT,SEGMENT,GENUS_CODE,DZGN_G));colnames(acutedz.gen)[colnames(acutedz.gen)=="DZGN_G"]<-"DZGN_G_den" #subset just acute diseased colonies
View(rdden.gen)
#Calc_CONDden_Transect
condden.gen<-Calc_CONDden_Seg(data=ad_sfm,grouping_field ="GENUS_CODE")# Density of condition colonies by condition, you will need to subset which ever condition you want
ble.gen<-subset(condden.gen,select = c(METHOD,SITEVISITID,SITE,TRANSECT,SEGMENT,GENUS_CODE,BLE));colnames(ble.gen)[colnames(ble.gen)=="BLE"]<-"BLE_den" #subset just bleached colonies
chronicdz.gen<-subset(condden.gen,select = c(METHOD,SITEVISITID,SITE,TRANSECT,SEGMENT,GENUS_CODE,CHRO));colnames(chronicdz.gen)[colnames(chronicdz.gen)=="CHRO"]<-"CHRO_den" #subset just chronic diseased colonies
View(chronicdz.gen)
View(ble.gen)
#Join density and partial moratlity data together.You will need to replace the DUMMY field with the one you want
data.gen <- join_all(list(acd.gen,jcd.gen,cl.gen,od.gen,rd.gen,chronicdz.gen,ble.gen),
by=c("METHOD","SITE","SITEVISITID","TRANSECT","SEGMENT","GENUS_CODE"), type='full')
head(data.gen)
#Change NAs for abunanance and density metrics to 0. Don't change NAs in the partial mortality columns to 0
data.gen$JuvColCount[is.na(data.gen$JuvColCount)]<-0;data.gen$JuvColDen[is.na(data.gen$JuvColDen)]<-0
data.gen$AdColCount[is.na(data.gen$AdColCount)]<-0;data.gen$AdColDen[is.na(data.gen$AdColDen)]<-0
data.gen$BLE_prev<-(data.gen$BLE_den*data.gen$SEGAREA_ad)/data.gen$AdColCount*100
data.gen$CHRO_prev<-(data.gen$CHRO_den*data.gen$SEGAREA_ad)/data.gen$AdColCount*100
View(data.gen)
#Concatenate method, Site,Transect and segment
data.gen$MethodRep<-paste(data.gen$METHOD,data.gen$TRANSECT,sep="_")
data.gen$SS<-paste(data.gen$SITE,data.gen$SEGMENT,sep="_")
t1<-as.data.frame.matrix(table(data.gen$SS,data.gen$MethodRep));dim(t1)
#Make final dataframe to save
data.gen2<-left_join(data.gen,survey_segment)
if(nrow(data.gen)!=nrow(data.gen2)) {cat("WARNING: Dfs didn't merge properly")}
View(data.gen)
View(data.gen2)
View(data.gen)
#Save file for segment calibration
write.csv(data.gen,file="T:/Benthic/Data/SfM/Calibration QC/MARAMP_repeats_GENUS_Summarized Data-CALIBRATION.csv",row.names = F)
data.gen<-read.csv("T:/Benthic/Data/SfM/Calibration QC/MARAMP_repeats_GENUS_Summarized Data-CALIBRATION.csv")
sfm<-data.gen[data.gen$METHOD=="SfM",];sfm<-droplevels(sfm)
table(sfm$SS,sfm$MethodRep)
View(data.gen)
